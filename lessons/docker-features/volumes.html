<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"/><link rel="icon" type="image/x-icon" href="/images/favicon.ico"/><title>Volumes – Complete Intro to Containers</title><meta name="description" content="Learn about the differences between bind mounts and volumes in Docker, how to persist data using volumes for containers, and create a Node.js app with Docker volumes. Understand the benefits of using volumes over bind mounts in Docker for data persistence and manageability."/><meta name="keywords" content="Docker bind mounts vs volumes,persist data in Docker containers,create Node.js app with Docker volumes"/><meta name="og:description" content="Learn about the differences between bind mounts and volumes in Docker, how to persist data using volumes for containers, and create a Node.js app with Docker volumes. Understand the benefits of using volumes over bind mounts in Docker for data persistence and manageability."/><meta name="og:title" content="Volumes – Complete Intro to Containers"/><meta name="og:image" content="/images/social-share-cover.jpg"/><meta name="twitter:card" content="summary_large_image"/><meta name="next-head-count" content="14"/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/cfac17cb37b27821.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/cfac17cb37b27821.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-4e7214a60fad8e88.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-5429a50ba5373c56.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-d2ba44903cd47711.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-564cf6bb10408614.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/lessons/%5Bsection%5D/%5Bslug%5D-ba225542c35827e2.js" defer="" crossorigin=""></script><script src="/_next/static/nARcRKX1ZlcrYUdSUSS9z/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/nARcRKX1ZlcrYUdSUSS9z/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="remix-app"><header class="navbar"><h1 class="navbar-brand"><a href="/">Complete Intro to Containers</a></h1><div class="navbar-info"><a href="https://holt.fyi/containers" class="cta-btn">Watch on Frontend Masters</a></div></header><div class="content-container"><div class="main"><div class="lesson-container"><div class="lesson"><div class="lesson-content"><p>Bind mounts are great for when you need to share data between your host and your container as we just learned. Volumes, on the other hand, are so that your containers can maintain state between runs. So if you have a container that runs and the next time it runs it needs the results from the previous time it ran, volumes are going to be helpful. Volumes can not only be shared by the same container-type between runs but also between different containers. Maybe if you have two containers and you want to log to consolidate your logs to one place, volumes could help with that.</p>
<p>They key here is this: bind mounts are file systems managed the host. They&#39;re just normal files in your host being mounted into a container. Volumes are different because they&#39;re a new file system that Docker manages that are mounted into your container. These Docker-managed file systems are not visible to the host system (they can be found but it&#39;s designed not to be.)</p>
<p>Let&#39;s make a quick Node.js app that reads from a file that a number in it, prints it, writes it to a volume, and finishes. Create a new Node.js project.</p>
<pre><code class="hljs language-bash"><span class="hljs-built_in">mkdir</span> docker-volume
<span class="hljs-built_in">cd</span> docker-volume
<span class="hljs-built_in">touch</span> index.js Dockerfile
</code></pre><p>Inside that index.js file, put this:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>).<span class="hljs-property">promises</span>;
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);

<span class="hljs-keyword">const</span> dataPath = path.<span class="hljs-title function_">join</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">DATA_PATH</span> || <span class="hljs-string">&quot;./data.txt&quot;</span>);

fs.<span class="hljs-title function_">readFile</span>(dataPath)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">buffer</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> data = buffer.<span class="hljs-title function_">toString</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
    <span class="hljs-title function_">writeTo</span>(+data + <span class="hljs-number">1</span>);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;file not found, writing &#x27;0&#x27; to a new file&quot;</span>);
    <span class="hljs-title function_">writeTo</span>(<span class="hljs-number">0</span>);
  });

<span class="hljs-keyword">const</span> <span class="hljs-title function_">writeTo</span> = (<span class="hljs-params">data</span>) =&gt; {
  fs.<span class="hljs-title function_">writeFile</span>(dataPath, data.<span class="hljs-title function_">toString</span>()).<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);
};
</code></pre><p>Don&#39;t worry too much about the index.js. It looks for a file <code>$DATA_PATH</code> if it exists or <code>./data.txt</code> if it doesn&#39;t and if it exists, it reads it, logs it, and writes back to the data file after incrementing the number. If it just run it right now, it&#39;ll create a <code>data.txt</code> file with 0 in it. If you run it again, it&#39;ll have <code>1</code> in there and so on. So let&#39;s make this work with volumes.</p>
<pre><code class="hljs language-dockerfile"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">20</span>-alpine
<span class="hljs-keyword">COPY</span><span class="language-bash"> --<span class="hljs-built_in">chown</span>=node:node . /src</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /src</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;index.js&quot;</span>]</span>
</code></pre><p>Now run</p>
<pre><code class="hljs language-bash">docker build -t incrementor .
docker run --<span class="hljs-built_in">rm</span> incrementor
</code></pre><p>Every time you run this it&#39;ll be the same thing. This is nothing is persisted once the container finishes. We need something that can live between runs. We could use bind mounts and it would work but this data is only designed to be used and written to within Docker which makes volumes preferable and recommended by Docker. If you use volumes, Docker can handle back ups, clean ups, and more security for you. If you use bind mounts, you&#39;re on your own.</p>
<p>So, without having to rebuild your container, try this</p>
<pre><code class="hljs language-bash">docker run --<span class="hljs-built_in">rm</span> --<span class="hljs-built_in">env</span> DATA_PATH=/data/num.txt --mount <span class="hljs-built_in">type</span>=volume,src=incrementor-data,target=/data incrementor
</code></pre><p>Now you should be to run it multiple times and everything should work! We use the <code>--env</code> flag to set the DATA_PATH to be where we want <code>index.js</code> to write the file and we use <code>--mount</code> to mount a named volume called <code>incrementor-data</code>. You can leave this out and it&#39;ll be an anonymous volume that will persist beyond the container but it won&#39;t automatically choose the right one on future runs. Awesome!</p>
<h2>named pipes, tmpfs, and wrap up</h2>
<p>Prefer to use volumes when you can, use bind mounts where it makes sense. If you&#39;re still unclear, the <a href="https://docs.docker.com/engine/storage/">official Docker storage</a> docs are pretty good on the subject.</p>
<p>There are two more that we didn&#39;t talk about, <code>tmpfs</code> and <code>npipe</code>. The former is Linux only and the latter is Windows only (we&#39;re not going over Windows containers at all in this workshop.) <code>tmpfs</code> imitates a file system but actually keeps everything in memory. This is useful for mounting in secrets like database keys or anything that wouldn&#39;t be persisted between container launches but you don&#39;t want to add to the Dockerfile. The latter is useful for mounting third party tools for Windows containers. If you need more info than that, refer to the docs. I&#39;ve never directly used either.</p>
</div><div class="lesson-links"><a href="/lessons/docker-features/bind-mounts" class="prev">← Previous</a><a href="/lessons/docker-features/dev-containers" class="next">Next →</a></div></div><div class="details-bg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="154" height="154" viewBox="0 0 154 154"><defs><clipPath id="clip-path"><rect id="Rectangle_2238" data-name="Rectangle 2238" width="154" height="154" transform="translate(9467 350)" fill="#fff" stroke="#707070" stroke-width="1"></rect></clipPath><clipPath id="clip-corner-image-active"><rect width="154" height="154"></rect></clipPath></defs><g id="corner-image-active" clip-path="url(#clip-corner-image-active)"><g id="Corner-image-active-2" data-name="Corner-image-active" transform="translate(-9467 -350)" clip-path="url(#clip-path)"><path id="Subtraction_34" data-name="Subtraction 34" d="M-3857.365,1740.766h0l-7.07-7.07,12.89-12.89v14.142l-5.818,5.818Zm-14.142-14.142h0l-7.071-7.07,27.033-27.033v14.143l-19.96,19.96Zm-14.143-14.143h0l-7.07-7.069,41.175-41.175v14.142Zm-14.142-14.142h0l-7.07-7.069,55.317-55.317v14.142Zm-14.142-14.142h0l-7.07-7.069,69.459-69.459v14.142Zm-14.142-14.142h0l-7.07-7.069,76.739-76.739h6.862v7.28Zm-14.143-14.143h0l-7.07-7.069,62.6-62.6h14.142Zm-14.142-14.142h0l-7.07-7.069,48.454-48.454h14.142Zm-14.142-14.142h0l-7.07-7.069,34.312-34.312h14.142Zm-14.142-14.142h0l-7.07-7.069,20.17-20.17h14.142Zm-14.142-14.142h0l-7.071-7.071,6.027-6.027h14.144l-13.1,13.1Zm367.24-56.114v-.909l.455.455-.453.453Z" transform="translate(13472.546 -1236.766)" fill="var(--corner-fill)"></path></g></g></svg></div></div></div></div><footer class="footer"><ul class="socials"><li class="social"><a href="https://twitter.com/holtbt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="40" height="32" viewBox="0 0 40 32"><defs><clipPath id="clip-twitter-social"><rect width="40" height="32"></rect></clipPath></defs><g id="twitter-social" clip-path="url(#clip-twitter-social)"><g id="Group_269" data-name="Group 269" transform="translate(-230.23 -1140.849)"><path id="Path_419" data-name="Path 419" d="M266.12,1148.861v1.035a23.092,23.092,0,0,1-1.507,8.1,24.08,24.08,0,0,1-4.475,7.381,22.175,22.175,0,0,1-7.306,5.4,24.129,24.129,0,0,1-10,2.07,23.7,23.7,0,0,1-6.667-.945,22.83,22.83,0,0,1-5.936-2.655q.959.091,1.963.09a16.518,16.518,0,0,0,5.434-.9,17.111,17.111,0,0,0,4.749-2.52,8.275,8.275,0,0,1-4.749-1.643,7.8,7.8,0,0,1-2.877-3.983,8.268,8.268,0,0,0,1.507.135,8.58,8.58,0,0,0,2.146-.27,8.16,8.16,0,0,1-5.685-4.344,8.326,8.326,0,0,1-.89-3.578v-.135a7.775,7.775,0,0,0,3.744,1.035,8.183,8.183,0,0,1-2.671-2.9,7.817,7.817,0,0,1-.982-3.848,7.948,7.948,0,0,1,1.1-4.05,23.53,23.53,0,0,0,16.895,8.46,9.221,9.221,0,0,1-.183-1.845,7.787,7.787,0,0,1,1.1-4.05,8.216,8.216,0,0,1,2.991-2.948,7.991,7.991,0,0,1,4.087-1.1,8.184,8.184,0,0,1,5.982,2.566,16.087,16.087,0,0,0,5.205-1.98,7.784,7.784,0,0,1-1.393,2.588,8.4,8.4,0,0,1-2.215,1.913,16.856,16.856,0,0,0,4.749-1.305A17.032,17.032,0,0,1,266.12,1148.861Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><a href="https://github.com/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-github-social"><rect width="32" height="32"></rect></clipPath></defs><g id="github-social" clip-path="url(#clip-github-social)"><g id="Group_272" data-name="Group 272" transform="translate(13522.5 -6994)"><path id="Subtraction_33" data-name="Subtraction 33" d="M-24967.5,8041a15.9,15.9,0,0,1-11.312-4.688A15.893,15.893,0,0,1-24983.5,8025a15.893,15.893,0,0,1,4.689-11.315A15.894,15.894,0,0,1-24967.5,8009a15.894,15.894,0,0,1,11.313,4.686A15.893,15.893,0,0,1-24951.5,8025a15.893,15.893,0,0,1-4.689,11.313A15.9,15.9,0,0,1-24967.5,8041Zm-3.781-4.571h0v3.918h7.895v-6.665a1.836,1.836,0,0,0-1.2-1.718c5.1-.617,7.467-2.975,7.467-7.424a7.176,7.176,0,0,0-1.637-4.728,6.74,6.74,0,0,0,.275-1.812,4.34,4.34,0,0,0-.52-2.452.574.574,0,0,0-.359-.1c-1.061,0-3.465,1.411-3.936,1.694a16.644,16.644,0,0,0-4.2-.489,16.379,16.379,0,0,0-3.969.445c-.846-.5-2.91-1.649-3.859-1.649a.566.566,0,0,0-.354.095,4.3,4.3,0,0,0-.521,2.452,6.7,6.7,0,0,0,.244,1.718,7.346,7.346,0,0,0-1.6,4.822,7.263,7.263,0,0,0,1.533,4.985c1.193,1.359,3.115,2.165,5.871,2.464a1.826,1.826,0,0,0-1.129,1.693v.5h0l-.006,0a7.121,7.121,0,0,1-2.033.363,2.608,2.608,0,0,1-.965-.158,4.438,4.438,0,0,1-1.836-1.881,2.361,2.361,0,0,0-1.248-1.091,3.472,3.472,0,0,0-1.217-.3.584.584,0,0,0-.545.224.282.282,0,0,0,.027.367,1.875,1.875,0,0,0,.447.307,4.732,4.732,0,0,1,.561.355,10.726,10.726,0,0,1,1.682,2.755c.043.092.078.163.105.217a3.876,3.876,0,0,0,2.42,1.185,6.036,6.036,0,0,0,.607.025c.875,0,1.988-.124,2-.125Z" transform="translate(11461 -1015)" fill="var(--footer-icons)"></path><g id="Ellipse_670" data-name="Ellipse 670" transform="translate(-13522.5 6994)" fill="none" stroke="var(--footer-icons)" stroke-width="1"><circle cx="16" cy="16" r="16" stroke="none"></circle><circle cx="16" cy="16" r="15.5" fill="none"></circle></g></g></g></svg></a></li><li class="social"><a href="https://linkedin.com/in/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-linkedin-social"><rect width="32" height="32"></rect></clipPath></defs><g id="linkedin-social" clip-path="url(#clip-linkedin-social)"><g id="Group_270" data-name="Group 270" transform="translate(-86.349 -633.073)"><path id="Path_375" data-name="Path 375" d="M115.789,633.073a2.324,2.324,0,0,1,1.682.676,2.194,2.194,0,0,1,.695,1.627V662.8a2.131,2.131,0,0,1-.695,1.609,2.314,2.314,0,0,1-1.646.659H88.69a2.307,2.307,0,0,1-1.646-.659,2.128,2.128,0,0,1-.695-1.609V635.376a2.19,2.19,0,0,1,.695-1.627,2.322,2.322,0,0,1,1.682-.676h27.063Zm-20.224,9.672a2.561,2.561,0,0,0,0-3.584,2.658,2.658,0,0,0-1.938-.712,2.724,2.724,0,0,0-1.957.712,2.371,2.371,0,0,0-.75,1.792,2.4,2.4,0,0,0,.731,1.792,2.605,2.605,0,0,0,1.9.713h.037A2.7,2.7,0,0,0,95.565,642.745ZM96,645.434H91.213V659.88H96Zm17.3,6.144a7.007,7.007,0,0,0-1.573-4.9,5.68,5.68,0,0,0-6.839-.769,5.663,5.663,0,0,0-1.426,1.573v-2.048H98.674q.036.841,0,7.717v6.728h4.791V651.8a3.592,3.592,0,0,1,.146-1.17,2.913,2.913,0,0,1,.878-1.206,2.429,2.429,0,0,1,1.609-.549,2.108,2.108,0,0,1,1.865.914,4.265,4.265,0,0,1,.549,2.341v7.752H113.3Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><div class="terms"><p>Content Licensed Under CC-BY-NC-4.0</p><p>Code Samples and Excercises Licensed Under Apache 2.0</p><p>Site Designed by<!-- --> <a href="https://www.alexdanielson.com/">Alex Danielson</a></p></div></li></ul></footer></div><script async="" defer="" src="https://a.holt.courses/latest.js"></script><noscript><img src="https://a.holt.courses/noscript.gif" alt="" referrerPolicy="no-referrer-when-downgrade"/></noscript></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"post":{"attributes":{"description":"Learn about the differences between bind mounts and volumes in Docker, how to persist data using volumes for containers, and create a Node.js app with Docker volumes. Understand the benefits of using volumes over bind mounts in Docker for data persistence and manageability.","keywords":["Docker bind mounts vs volumes","persist data in Docker containers","create Node.js app with Docker volumes"]},"html":"\u003cp\u003eBind mounts are great for when you need to share data between your host and your container as we just learned. Volumes, on the other hand, are so that your containers can maintain state between runs. So if you have a container that runs and the next time it runs it needs the results from the previous time it ran, volumes are going to be helpful. Volumes can not only be shared by the same container-type between runs but also between different containers. Maybe if you have two containers and you want to log to consolidate your logs to one place, volumes could help with that.\u003c/p\u003e\n\u003cp\u003eThey key here is this: bind mounts are file systems managed the host. They\u0026#39;re just normal files in your host being mounted into a container. Volumes are different because they\u0026#39;re a new file system that Docker manages that are mounted into your container. These Docker-managed file systems are not visible to the host system (they can be found but it\u0026#39;s designed not to be.)\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s make a quick Node.js app that reads from a file that a number in it, prints it, writes it to a volume, and finishes. Create a new Node.js project.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-built_in\"\u003emkdir\u003c/span\u003e docker-volume\n\u003cspan class=\"hljs-built_in\"\u003ecd\u003c/span\u003e docker-volume\n\u003cspan class=\"hljs-built_in\"\u003etouch\u003c/span\u003e index.js Dockerfile\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eInside that index.js file, put this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fs = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;fs\u0026quot;\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003epromises\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e path = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;path\u0026quot;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dataPath = path.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDATA_PATH\u003c/span\u003e || \u003cspan class=\"hljs-string\"\u003e\u0026quot;./data.txt\u0026quot;\u003c/span\u003e);\n\nfs.\u003cspan class=\"hljs-title function_\"\u003ereadFile\u003c/span\u003e(dataPath)\n  .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ebuffer\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = buffer.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e();\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(data);\n    \u003cspan class=\"hljs-title function_\"\u003ewriteTo\u003c/span\u003e(+data + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  })\n  .\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;file not found, writing \u0026#x27;0\u0026#x27; to a new file\u0026quot;\u003c/span\u003e);\n    \u003cspan class=\"hljs-title function_\"\u003ewriteTo\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n  });\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ewriteTo\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u0026gt; {\n  fs.\u003cspan class=\"hljs-title function_\"\u003ewriteFile\u003c/span\u003e(dataPath, data.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e()).\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eerror\u003c/span\u003e);\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDon\u0026#39;t worry too much about the index.js. It looks for a file \u003ccode\u003e$DATA_PATH\u003c/code\u003e if it exists or \u003ccode\u003e./data.txt\u003c/code\u003e if it doesn\u0026#39;t and if it exists, it reads it, logs it, and writes back to the data file after incrementing the number. If it just run it right now, it\u0026#39;ll create a \u003ccode\u003edata.txt\u003c/code\u003e file with 0 in it. If you run it again, it\u0026#39;ll have \u003ccode\u003e1\u003c/code\u003e in there and so on. So let\u0026#39;s make this work with volumes.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dockerfile\"\u003e\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e node:\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e-alpine\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"language-bash\"\u003e --\u003cspan class=\"hljs-built_in\"\u003echown\u003c/span\u003e=node:node . /src\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eWORKDIR\u003c/span\u003e\u003cspan class=\"language-bash\"\u003e /src\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eCMD\u003c/span\u003e\u003cspan class=\"language-bash\"\u003e [\u003cspan class=\"hljs-string\"\u003e\u0026quot;node\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;index.js\u0026quot;\u003c/span\u003e]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow run\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003edocker build -t incrementor .\ndocker run --\u003cspan class=\"hljs-built_in\"\u003erm\u003c/span\u003e incrementor\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEvery time you run this it\u0026#39;ll be the same thing. This is nothing is persisted once the container finishes. We need something that can live between runs. We could use bind mounts and it would work but this data is only designed to be used and written to within Docker which makes volumes preferable and recommended by Docker. If you use volumes, Docker can handle back ups, clean ups, and more security for you. If you use bind mounts, you\u0026#39;re on your own.\u003c/p\u003e\n\u003cp\u003eSo, without having to rebuild your container, try this\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003edocker run --\u003cspan class=\"hljs-built_in\"\u003erm\u003c/span\u003e --\u003cspan class=\"hljs-built_in\"\u003eenv\u003c/span\u003e DATA_PATH=/data/num.txt --mount \u003cspan class=\"hljs-built_in\"\u003etype\u003c/span\u003e=volume,src=incrementor-data,target=/data incrementor\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow you should be to run it multiple times and everything should work! We use the \u003ccode\u003e--env\u003c/code\u003e flag to set the DATA_PATH to be where we want \u003ccode\u003eindex.js\u003c/code\u003e to write the file and we use \u003ccode\u003e--mount\u003c/code\u003e to mount a named volume called \u003ccode\u003eincrementor-data\u003c/code\u003e. You can leave this out and it\u0026#39;ll be an anonymous volume that will persist beyond the container but it won\u0026#39;t automatically choose the right one on future runs. Awesome!\u003c/p\u003e\n\u003ch2\u003enamed pipes, tmpfs, and wrap up\u003c/h2\u003e\n\u003cp\u003ePrefer to use volumes when you can, use bind mounts where it makes sense. If you\u0026#39;re still unclear, the \u003ca href=\"https://docs.docker.com/engine/storage/\"\u003eofficial Docker storage\u003c/a\u003e docs are pretty good on the subject.\u003c/p\u003e\n\u003cp\u003eThere are two more that we didn\u0026#39;t talk about, \u003ccode\u003etmpfs\u003c/code\u003e and \u003ccode\u003enpipe\u003c/code\u003e. The former is Linux only and the latter is Windows only (we\u0026#39;re not going over Windows containers at all in this workshop.) \u003ccode\u003etmpfs\u003c/code\u003e imitates a file system but actually keeps everything in memory. This is useful for mounting in secrets like database keys or anything that wouldn\u0026#39;t be persisted between container launches but you don\u0026#39;t want to add to the Dockerfile. The latter is useful for mounting third party tools for Windows containers. If you need more info than that, refer to the docs. I\u0026#39;ve never directly used either.\u003c/p\u003e\n","markdown":"\nBind mounts are great for when you need to share data between your host and your container as we just learned. Volumes, on the other hand, are so that your containers can maintain state between runs. So if you have a container that runs and the next time it runs it needs the results from the previous time it ran, volumes are going to be helpful. Volumes can not only be shared by the same container-type between runs but also between different containers. Maybe if you have two containers and you want to log to consolidate your logs to one place, volumes could help with that.\n\nThey key here is this: bind mounts are file systems managed the host. They're just normal files in your host being mounted into a container. Volumes are different because they're a new file system that Docker manages that are mounted into your container. These Docker-managed file systems are not visible to the host system (they can be found but it's designed not to be.)\n\nLet's make a quick Node.js app that reads from a file that a number in it, prints it, writes it to a volume, and finishes. Create a new Node.js project.\n\n```bash\nmkdir docker-volume\ncd docker-volume\ntouch index.js Dockerfile\n```\n\nInside that index.js file, put this:\n\n```javascript\nconst fs = require(\"fs\").promises;\nconst path = require(\"path\");\n\nconst dataPath = path.join(process.env.DATA_PATH || \"./data.txt\");\n\nfs.readFile(dataPath)\n  .then((buffer) =\u003e {\n    const data = buffer.toString();\n    console.log(data);\n    writeTo(+data + 1);\n  })\n  .catch((e) =\u003e {\n    console.log(\"file not found, writing '0' to a new file\");\n    writeTo(0);\n  });\n\nconst writeTo = (data) =\u003e {\n  fs.writeFile(dataPath, data.toString()).catch(console.error);\n};\n```\n\nDon't worry too much about the index.js. It looks for a file `$DATA_PATH` if it exists or `./data.txt` if it doesn't and if it exists, it reads it, logs it, and writes back to the data file after incrementing the number. If it just run it right now, it'll create a `data.txt` file with 0 in it. If you run it again, it'll have `1` in there and so on. So let's make this work with volumes.\n\n```dockerfile\nFROM node:20-alpine\nCOPY --chown=node:node . /src\nWORKDIR /src\nCMD [\"node\", \"index.js\"]\n```\n\nNow run\n\n```bash\ndocker build -t incrementor .\ndocker run --rm incrementor\n```\n\nEvery time you run this it'll be the same thing. This is nothing is persisted once the container finishes. We need something that can live between runs. We could use bind mounts and it would work but this data is only designed to be used and written to within Docker which makes volumes preferable and recommended by Docker. If you use volumes, Docker can handle back ups, clean ups, and more security for you. If you use bind mounts, you're on your own.\n\nSo, without having to rebuild your container, try this\n\n```bash\ndocker run --rm --env DATA_PATH=/data/num.txt --mount type=volume,src=incrementor-data,target=/data incrementor\n```\n\nNow you should be to run it multiple times and everything should work! We use the `--env` flag to set the DATA_PATH to be where we want `index.js` to write the file and we use `--mount` to mount a named volume called `incrementor-data`. You can leave this out and it'll be an anonymous volume that will persist beyond the container but it won't automatically choose the right one on future runs. Awesome!\n\n## named pipes, tmpfs, and wrap up\n\nPrefer to use volumes when you can, use bind mounts where it makes sense. If you're still unclear, the [official Docker storage](https://docs.docker.com/engine/storage/) docs are pretty good on the subject.\n\nThere are two more that we didn't talk about, `tmpfs` and `npipe`. The former is Linux only and the latter is Windows only (we're not going over Windows containers at all in this workshop.) `tmpfs` imitates a file system but actually keeps everything in memory. This is useful for mounting in secrets like database keys or anything that wouldn't be persisted between container launches but you don't want to add to the Dockerfile. The latter is useful for mounting third party tools for Windows containers. If you need more info than that, refer to the docs. I've never directly used either.\n","slug":"volumes","title":"Volumes","section":"Docker Features","icon":"box","filePath":"/home/runner/work/complete-intro-to-containers-v2/complete-intro-to-containers-v2/lessons/06-docker-features/B-volumes.md","nextSlug":"/lessons/docker-features/dev-containers","prevSlug":"/lessons/docker-features/bind-mounts"}},"__N_SSG":true},"page":"/lessons/[section]/[slug]","query":{"section":"docker-features","slug":"volumes"},"buildId":"nARcRKX1ZlcrYUdSUSS9z","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>