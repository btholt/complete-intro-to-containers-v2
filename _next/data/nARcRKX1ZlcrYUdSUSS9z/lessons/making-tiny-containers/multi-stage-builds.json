{"pageProps":{"post":{"attributes":{"description":"Learn how to optimize Docker images using multistage builds with Node.js and Alpine, reducing container size significantly by eliminating unnecessary dependencies like npm. Follow a tutorial on building a Dockerfile with multiple stages and leveraging Alpine for smaller, more efficient containers.","keywords":["Docker multistage build","Node.js Alpine Docker image","optimize Docker image size"]},"html":"<p>Hey, we&#39;re already half-way to ridiculous, let&#39;s make our image EVEN SMALLER. Technically we only need <code>npm</code> to build our app, right? We don&#39;t actually need it to run our app. Docker allows you to have what it called multistage builds, we it uses one container to build your app and another to run it. This can be useful if you have big dependencies to build your app but you don&#39;t need those dependencies to actually run the app. A C++ or Rust app might be a good example of that: they need big tool chains to compile the apps but the resulting binaries are smaller and don&#39;t need those tools to actually run them. Or one perhaps more applicable to you is that you don&#39;t need the TypeScript or Sass compiler in production, just the compiled files. We&#39;ll actually do that here in a sec, but let&#39;s start here with eliminating <code>npm</code>.</p>\n<p>Make a new Dockerfile, call it <code>Dockerfile</code>.</p>\n<pre><code class=\"hljs language-dockerfile\"><span class=\"hljs-comment\"># build stage</span>\n<span class=\"hljs-keyword\">FROM</span> node:<span class=\"hljs-number\">20</span> AS node-builder\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> <span class=\"hljs-built_in\">mkdir</span> /build</span>\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"language-bash\"> /build</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> package-lock.json package.json ./</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> npm ci</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> . .</span>\n\n<span class=\"hljs-comment\"># runtime stage</span>\n<span class=\"hljs-keyword\">FROM</span> alpine:<span class=\"hljs-number\">3.19</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> apk add --update nodejs</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> addgroup -S node &amp;&amp; adduser -S node -G node</span>\n<span class=\"hljs-keyword\">USER</span> node\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> <span class=\"hljs-built_in\">mkdir</span> /home/node/code</span>\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"language-bash\"> /home/node/code</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> --from=node-builder --<span class=\"hljs-built_in\">chown</span>=node:node /build .</span>\n<span class=\"hljs-keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"hljs-string\">&quot;node&quot;</span>, <span class=\"hljs-string\">&quot;index.js&quot;</span>]</span>\n</code></pre><p>Notice we have have two <code>FROM</code> instructions. This is how you can tell it&#39;s multistage. The last container made will be the final one that gets labeled and shipped. Notice we&#39;re starting in the full <code>node:20</code> container since we&#39;re not going to ship this container so we can use the kitchen sink to build it before it copying it to a smaller container.</p>\n<p>After building everything in the build stage (you can have more than two stages by the way) we move on to the runtime container. In this one we&#39;re using Alpine due its size and security benefits. Everything else looks similar to what we were doing before, just now we&#39;re going to be copying from the build container instead of the host machine.</p>\n<p>The two real key differences are that we don&#39;t <code>apk add npm</code> and we&#39;re doing <code>COPY --from=my-node</code> which means we&#39;re copying from the first stage. We do <code>FROM node:20 AS node-builder</code> so we can refer to node-builder by name which simplifies reading the Dockerfile.</p>\n<p>As you may imagine, this means you can copy from any previous stage or if you leave <code>--from</code> off it&#39;ll come from the host machine.</p>\n<p>So try it now!</p>\n<pre><code class=\"hljs language-bash\">docker build -t my-multi .\ndocker run -it -p 8080:8080 --name my-app --<span class=\"hljs-built_in\">rm</span> --init my-multi\n</code></pre><p>Still works! And our container size is down to a cool 72MB as compared to 89MB when we included npm, 150MB when we used <code>node:20-alpine</code> and 1.1GB when we used <code>node:20</code>.</p>\n<p>Pretty amazing, right? Honestly, how worth is it doing micro optimization like this? Not very. We had to do a decent amount to shave 50% off the final size and now we&#39;re stuck maintaining it. I&#39;d rather just start with <code>FROM node:20-alpine</code> and call it a day. We get all their wisdom for free and we&#39;re not stuck with a longer Dockerfile than we need. But it is definitely worth going from 1.1GB to 150MB!</p>\n<h2>A note on container sizes</h2>\n<p>A last note here: file size isn&#39;t everything. It&#39;s at best weakly correlated with security, it&#39;s just a fun metric to measure. In theory you&#39;ll save some money on bandwidth but I have to guess you&#39;ll spend more engineering salaries making containers tiny than you&#39;ll save on bandwidth. I&#39;d much rather have <code>node:20</code> and have it be maintained by security professionals than trying to do it myself. Just keep that in mind: it can be a fool&#39;s errand to chase shaving bytes off your containers.</p>\n","markdown":"\nHey, we're already half-way to ridiculous, let's make our image EVEN SMALLER. Technically we only need `npm` to build our app, right? We don't actually need it to run our app. Docker allows you to have what it called multistage builds, we it uses one container to build your app and another to run it. This can be useful if you have big dependencies to build your app but you don't need those dependencies to actually run the app. A C++ or Rust app might be a good example of that: they need big tool chains to compile the apps but the resulting binaries are smaller and don't need those tools to actually run them. Or one perhaps more applicable to you is that you don't need the TypeScript or Sass compiler in production, just the compiled files. We'll actually do that here in a sec, but let's start here with eliminating `npm`.\n\nMake a new Dockerfile, call it `Dockerfile`.\n\n```dockerfile\n# build stage\nFROM node:20 AS node-builder\nRUN mkdir /build\nWORKDIR /build\nCOPY package-lock.json package.json ./\nRUN npm ci\nCOPY . .\n\n# runtime stage\nFROM alpine:3.19\nRUN apk add --update nodejs\nRUN addgroup -S node && adduser -S node -G node\nUSER node\nRUN mkdir /home/node/code\nWORKDIR /home/node/code\nCOPY --from=node-builder --chown=node:node /build .\nCMD [\"node\", \"index.js\"]\n```\n\nNotice we have have two `FROM` instructions. This is how you can tell it's multistage. The last container made will be the final one that gets labeled and shipped. Notice we're starting in the full `node:20` container since we're not going to ship this container so we can use the kitchen sink to build it before it copying it to a smaller container.\n\nAfter building everything in the build stage (you can have more than two stages by the way) we move on to the runtime container. In this one we're using Alpine due its size and security benefits. Everything else looks similar to what we were doing before, just now we're going to be copying from the build container instead of the host machine.\n\nThe two real key differences are that we don't `apk add npm` and we're doing `COPY --from=my-node` which means we're copying from the first stage. We do `FROM node:20 AS node-builder` so we can refer to node-builder by name which simplifies reading the Dockerfile.\n\nAs you may imagine, this means you can copy from any previous stage or if you leave `--from` off it'll come from the host machine.\n\nSo try it now!\n\n```bash\ndocker build -t my-multi .\ndocker run -it -p 8080:8080 --name my-app --rm --init my-multi\n```\n\nStill works! And our container size is down to a cool 72MB as compared to 89MB when we included npm, 150MB when we used `node:20-alpine` and 1.1GB when we used `node:20`.\n\nPretty amazing, right? Honestly, how worth is it doing micro optimization like this? Not very. We had to do a decent amount to shave 50% off the final size and now we're stuck maintaining it. I'd rather just start with `FROM node:20-alpine` and call it a day. We get all their wisdom for free and we're not stuck with a longer Dockerfile than we need. But it is definitely worth going from 1.1GB to 150MB!\n\n## A note on container sizes\n\nA last note here: file size isn't everything. It's at best weakly correlated with security, it's just a fun metric to measure. In theory you'll save some money on bandwidth but I have to guess you'll spend more engineering salaries making containers tiny than you'll save on bandwidth. I'd much rather have `node:20` and have it be maintained by security professionals than trying to do it myself. Just keep that in mind: it can be a fool's errand to chase shaving bytes off your containers.\n","slug":"multi-stage-builds","title":"Multi Stage Builds","section":"Making Tiny Containers","icon":"minimize","filePath":"/home/runner/work/complete-intro-to-containers-v2/complete-intro-to-containers-v2/lessons/05-making-tiny-containers/C-multi-stage-builds.md","nextSlug":"/lessons/making-tiny-containers/distroless","prevSlug":"/lessons/making-tiny-containers/making-our-own-alpine-nodejs-container"}},"__N_SSG":true}