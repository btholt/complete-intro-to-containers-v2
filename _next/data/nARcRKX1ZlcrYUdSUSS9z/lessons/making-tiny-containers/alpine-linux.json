{"pageProps":{"post":{"attributes":{"description":"Learn how to make your Node.js app container faster, cheaper, and more secure by optimizing its size. Reduce vulnerabilities and hosting costs with tips on minimizing container size using Alpine Linux in Docker.","keywords":["Node.js","container optimization","Alpine Linux","Docker","security","cost-effective hosting"]},"html":"<p>We&#39;ve now built a nice little container for our Node.js app and we absolutely could ship it as-is to production. However there&#39;s a few things we can do to make things even faster, cheaper, and more secure.</p>\n<h2>Making your containers smaller</h2>\n<p>Making your containers smaller is a good thing for a few reasons. For one, everything tends to get a bit cheaper. Moving containers across the Internet takes time and bits to do. If you can make those containers smaller, things will go faster and you&#39;ll require less space on your servers. Often private container registries (like personal Docker Hubs, Azure Container Registry is a good example) charge you by how much storage you&#39;re using.</p>\n<p>Beyond that, having less <em>things</em> in your container means you&#39;re less susceptible to bugs. Let&#39;s say there&#39;s a Python exploit that&#39;s going around that allows hackers to get root access to your container. If you don&#39;t have Python in your container, you&#39;re not vulnerable! And obviously if you do have Python installed (even if you&#39;re not using it) you&#39;re vulnerable. So let&#39;s see how to make your container a bit smaller.</p>\n<p>In your previous Dockerfile, change the first line (<code>FROM</code>)</p>\n<pre><code class=\"hljs language-dockerfile\"><span class=\"hljs-keyword\">FROM</span> node:<span class=\"hljs-number\">20</span>-alpine\n\n<span class=\"hljs-keyword\">USER</span> node\n\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> <span class=\"hljs-built_in\">mkdir</span> /home/node/code</span>\n\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"language-bash\"> /home/node/code</span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> --<span class=\"hljs-built_in\">chown</span>=node:node package-lock.json package.json ./</span>\n\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> npm ci</span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> --<span class=\"hljs-built_in\">chown</span>=node:node . .</span>\n\n<span class=\"hljs-keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"hljs-string\">&quot;node&quot;</span>, <span class=\"hljs-string\">&quot;index.js&quot;</span>]</span>\n</code></pre><p><a href=\"https://github.com/btholt/project-files-for-complete-intro-to-containers-v2/blob/main/alpine-linux/Dockerfile\">⛓️ Link to the Dockerfile</a></p>\n<p>Our image size (by comparing the <code>&quot;Size&quot;</code> field in in <code>docker inspect my-app</code>) from 1.1GB to 150MB just like that. We shed quite a bit of cruft that we didn&#39;t need in Debian and we didn&#39;t even need to change anything in our Dockerfile. Honestly, that&#39;s unusual. When you strip <em>everything</em> out typically you&#39;ll have to go back and add some of them back in. But in this case we&#39;re golden!</p>\n<p>Alpine, if you remember, is a bare bones alternative to Debian. It&#39;s built on Busybox Linux which is a 2MB distro of Linux (Alpine is 5MB.) <code>node:20-alpine</code> itself is about <code>133MB</code> and <code>node:latest</code> is about 1.0GB.</p>\n<p>When should you select Alpine? My general feeling (this is a Brian Holt opinion, not a community one so take it with a grain of salt) is that the &quot;end destination&quot; container is where Alpine is most useful. It cuts all cruft out which is super helpful for end-deployment sorts of scenarios due to security and size but it also can be annoying for development scenarios because it lacks just about everything necessary for those, making you have to hand install everything you need. In these &quot;middle scenarios&quot; where it&#39;s not really the destination and the container is just another tool in your development system (where that&#39;s a multi stage build or a development container) I&#39;ll reach for Ubuntu or Debian.</p>\n","markdown":"\nWe've now built a nice little container for our Node.js app and we absolutely could ship it as-is to production. However there's a few things we can do to make things even faster, cheaper, and more secure.\n\n## Making your containers smaller\n\nMaking your containers smaller is a good thing for a few reasons. For one, everything tends to get a bit cheaper. Moving containers across the Internet takes time and bits to do. If you can make those containers smaller, things will go faster and you'll require less space on your servers. Often private container registries (like personal Docker Hubs, Azure Container Registry is a good example) charge you by how much storage you're using.\n\nBeyond that, having less _things_ in your container means you're less susceptible to bugs. Let's say there's a Python exploit that's going around that allows hackers to get root access to your container. If you don't have Python in your container, you're not vulnerable! And obviously if you do have Python installed (even if you're not using it) you're vulnerable. So let's see how to make your container a bit smaller.\n\nIn your previous Dockerfile, change the first line (`FROM`)\n\n```dockerfile\nFROM node:20-alpine\n\nUSER node\n\nRUN mkdir /home/node/code\n\nWORKDIR /home/node/code\n\nCOPY --chown=node:node package-lock.json package.json ./\n\nRUN npm ci\n\nCOPY --chown=node:node . .\n\nCMD [\"node\", \"index.js\"]\n```\n\n[⛓️ Link to the Dockerfile][dockerfile-file]\n\nOur image size (by comparing the `\"Size\"` field in in `docker inspect my-app`) from 1.1GB to 150MB just like that. We shed quite a bit of cruft that we didn't need in Debian and we didn't even need to change anything in our Dockerfile. Honestly, that's unusual. When you strip _everything_ out typically you'll have to go back and add some of them back in. But in this case we're golden!\n\nAlpine, if you remember, is a bare bones alternative to Debian. It's built on Busybox Linux which is a 2MB distro of Linux (Alpine is 5MB.) `node:20-alpine` itself is about `133MB` and `node:latest` is about 1.0GB.\n\nWhen should you select Alpine? My general feeling (this is a Brian Holt opinion, not a community one so take it with a grain of salt) is that the \"end destination\" container is where Alpine is most useful. It cuts all cruft out which is super helpful for end-deployment sorts of scenarios due to security and size but it also can be annoying for development scenarios because it lacks just about everything necessary for those, making you have to hand install everything you need. In these \"middle scenarios\" where it's not really the destination and the container is just another tool in your development system (where that's a multi stage build or a development container) I'll reach for Ubuntu or Debian.\n\n[dockerfile-file]: https://github.com/btholt/project-files-for-complete-intro-to-containers-v2/blob/main/alpine-linux/Dockerfile\n","slug":"alpine-linux","title":"Alpine Linux","section":"Making Tiny Containers","icon":"minimize","filePath":"/home/runner/work/complete-intro-to-containers-v2/complete-intro-to-containers-v2/lessons/05-making-tiny-containers/A-alpine-linux.md","nextSlug":"/lessons/making-tiny-containers/making-our-own-alpine-nodejs-container","prevSlug":"/lessons/dockerfiles/layers"}},"__N_SSG":true}