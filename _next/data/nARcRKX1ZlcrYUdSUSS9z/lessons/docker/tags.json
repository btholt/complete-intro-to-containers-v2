{"pageProps":{"post":{"attributes":{"description":"Learn how to manage Docker container versions, from using the latest tag to specifying specific versions for Node.js and exploring Alpine Linux for minimalistic container deployments. Discover the benefits of choosing lightweight Alpine containers over larger Ubuntu or Debian images for faster deployment, reduced storage costs, and enhanced security.","keywords":["Docker containers","version management","Alpine Linux","Node.js","container deployment","security","minimalist containers"]},"html":"<p>So far we&#39;ve just been running containers with random tags that I chose. If you run <code>docker run -it node</code> the tag implicitly is using the <code>latest</code> tag. When you say <code>docker run -it node</code>, it&#39;s the same as saying <code>docker run -it node:latest</code>. The <code>:latest</code> is the tag. This allows you to run different versions of the same container, just like you can install React version 17 or React version 18: some times you don&#39;t want the latest. Let&#39;s say you have a legacy application at your job and it depends on running on Node.js 20 (update your app, Node.js is already past end-of-life) then you can say</p>\n<pre><code class=\"hljs language-bash\">docker run -it node:20 bash\n</code></pre><p>Once in the shell, run <code>node --version</code> and you&#39;ll see the Node.js version is 20.<em>.</em>! Neat! This is helpful because now we can fix our Node.js version to the one our app expects. Hop back over to <a href=\"https://hub.docker.com/_/node/\">the Docker Hub page for the node container</a>. Take a look at all the version of the node container you can download. Let&#39;s try another one.</p>\n<pre><code class=\"hljs language-bash\">docker run node:20-alpine <span class=\"hljs-built_in\">cat</span> /etc/issue\n</code></pre><p>You&#39;ll see this is running an entirely different OS all together: Alpine! <a href=\"https://hub.docker.com/_/alpine\">Alpine Linux</a> is a very, very tiny distro of Linux made for containers and specifically because it is tiny. Alpine containers are bare bones: if you want <em>anything</em> in them, you&#39;re going to have to do it yourself. This is in opposition to the Ubuntu and Debian containers: they ship the kitchen sink with them which is both convenient and much bigger in size. Alpine images are about five megabytes whereas Ubuntu is close to two hundred megabytes. As you can imagine, this can make a difference in how fast you can deploy and can cost significantly less in terms of storage and network traffic. It&#39;s also in general better to have less unnecessary things in your containers: less is more in terms of security. If an attacker tries to execute a Python exploit on your container but your container doesn&#39;t have Python then their attack won&#39;t work.</p>\n<p>We&#39;ll get more into how to ship containers to production but I&#39;ll leave you with this pro-tip: have a development container which has all the bells, whistles, debugging tools, etc. that you need. Then have a production container that&#39;s minimalist as possibly can be. You&#39;ll get the best of both worlds.</p>\n","markdown":"\nSo far we've just been running containers with random tags that I chose. If you run `docker run -it node` the tag implicitly is using the `latest` tag. When you say `docker run -it node`, it's the same as saying `docker run -it node:latest`. The `:latest` is the tag. This allows you to run different versions of the same container, just like you can install React version 17 or React version 18: some times you don't want the latest. Let's say you have a legacy application at your job and it depends on running on Node.js 20 (update your app, Node.js is already past end-of-life) then you can say\n\n```bash\ndocker run -it node:20 bash\n```\n\nOnce in the shell, run `node --version` and you'll see the Node.js version is 20._._! Neat! This is helpful because now we can fix our Node.js version to the one our app expects. Hop back over to [the Docker Hub page for the node container][node]. Take a look at all the version of the node container you can download. Let's try another one.\n\n```bash\ndocker run node:20-alpine cat /etc/issue\n```\n\nYou'll see this is running an entirely different OS all together: Alpine! [Alpine Linux][alpine] is a very, very tiny distro of Linux made for containers and specifically because it is tiny. Alpine containers are bare bones: if you want _anything_ in them, you're going to have to do it yourself. This is in opposition to the Ubuntu and Debian containers: they ship the kitchen sink with them which is both convenient and much bigger in size. Alpine images are about five megabytes whereas Ubuntu is close to two hundred megabytes. As you can imagine, this can make a difference in how fast you can deploy and can cost significantly less in terms of storage and network traffic. It's also in general better to have less unnecessary things in your containers: less is more in terms of security. If an attacker tries to execute a Python exploit on your container but your container doesn't have Python then their attack won't work.\n\nWe'll get more into how to ship containers to production but I'll leave you with this pro-tip: have a development container which has all the bells, whistles, debugging tools, etc. that you need. Then have a production container that's minimalist as possibly can be. You'll get the best of both worlds.\n\n[node]: https://hub.docker.com/_/node/\n[alpine]: https://hub.docker.com/_/alpine\n","slug":"tags","title":"Tags","section":"Docker","icon":"fish","filePath":"/home/runner/work/complete-intro-to-containers-v2/complete-intro-to-containers-v2/lessons/03-docker/D-tags.md","nextSlug":"/lessons/docker/docker-cli","prevSlug":"/lessons/docker/javascript-on-docker"}},"__N_SSG":true}