{"pageProps":{"post":{"attributes":{"title":"Build a Node.js App","description":"Learn how to set up a basic Node.js application inside Docker with detailed steps on copying files, exposing ports, and user permissions. Enhance your Dockerfile skills by optimizing file structures and using instructions like COPY, USER, and WORKDIR effectively.","keywords":["Dockerfile","Node.js application","Docker setup","copy files in Docker","expose ports in Docker","user permissions in Docker","WORKDIR instruction"]},"html":"<p>So now let&#39;s dig into some more advance things you can do with a Dockerfile. Let&#39;s first make our project a real Node.js application. Make a file called <code>index.js</code> and put this in there.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;http&quot;</span>);\n\nhttp\n  .<span class=\"hljs-title function_\">createServer</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">request, response</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;request received&quot;</span>);\n    response.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&quot;omg hi&quot;</span>, <span class=\"hljs-string\">&quot;utf-8&quot;</span>);\n  })\n  .<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;server started&quot;</span>);\n</code></pre><p><a href=\"https://github.com/btholt/project-files-for-complete-intro-to-containers-v2/blob/main/build-a-nodejs-app/index.js\">⛓️ Link to Node.js file</a></p>\n<p>This more-or-less that most barebones Node.js app you can write. It just responds to HTTP traffic on port 3000. Go ahead and try running it on your local computer (outside of Docker) by running <code>node index.js</code>. Open <a href=\"http://localhost:3000\">localhost:3000</a> in your browser to give it a shot.</p>\n<p>Okay, so let&#39;s get this running <em>inside</em> Docker now. First thing is we have to copy this file from your local file system into the container. We&#39;ll use a new instruction, <code>COPY</code>. Modify your Dockerfile to say:</p>\n<pre><code class=\"hljs language-dockerfile\"><span class=\"hljs-keyword\">FROM</span> node:<span class=\"hljs-number\">20</span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> index.js index.js</span>\n\n<span class=\"hljs-keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"hljs-string\">&quot;node&quot;</span>, <span class=\"hljs-string\">&quot;index.js&quot;</span>]</span>\n</code></pre><p><a href=\"https://github.com/btholt/project-files-for-complete-intro-to-containers-v2/blob/main/build-a-nodejs-app/Dockerfile\">⛓️ Link to Dockerfile</a></p>\n<p>This will copy your index.js file from your file system into the Docker file system (the first index.js is the source and the second index.js is the destination of that file inside the container.)</p>\n<p>We then modified the <code>CMD</code> to start the server when we finally do run the container. Now run</p>\n<pre><code class=\"hljs language-bash\">docker build -t my-node-app .\ndocker run --name my-app --<span class=\"hljs-built_in\">rm</span> my-node-app\n</code></pre><p>You might need to open another terminal and type <code>docker kill my-app</code>.</p>\n<p>Now your Node.js app is running inside of a container managed by Docker! Hooray! But one problem, how do we access it? If you open <a href=\"http://localhost:3000\">locahlost:3000</a> now, it doesn&#39;t work! We have to tell Docker to expose the port. So let&#39;s do that now. Stop your container from running and run it again like this.</p>\n<p>Try stopping your server now. Your normal CTRL+C won&#39;t work. Node.js itself doesn&#39;t handle SIGINT (which is what CTRL+C is) in and of itself. Instead you either have to handle it yourself inside of your Node.js code (preferable for real apps) or you can tell Docker to handle it with the <code>--init</code> flag. This uses a package called <a href=\"https://github.com/krallin/tini\">tini</a> to handle shutdown signal for you.</p>\n<pre><code class=\"hljs language-bash\">docker run --init --publish 3000:3000 --<span class=\"hljs-built_in\">rm</span> my-node-app <span class=\"hljs-comment\"># or you can use -p instead of --publish</span>\n</code></pre><p>The <code>publish</code> part allows you to forward a port out of a container to the host computer. In this case we&#39;re forwarding the port of <code>3000</code> (which is what the Node.js server was listening on) to port <code>3000</code> on the host machine. The <code>3000</code> represents the port on the host machine and the second <code>3000</code> represents what port is being used in the container. If you did <code>docker run --publish 8000:3000 my-node-app</code>, you&#39;d open <code>localhost:8000</code> to see the server (running on port <code>3000</code> inside the container).</p>\n<p>Next, let&#39;s organize ourselves a bit better. Right now we&#39;re putting our app into the root directory of our container and running it as the root user. This both messy and unsafe. If there&#39;s an exploit for Node.js that get released, it means that whoever uses that exploit on our Node.js server will doing so as root which means they can do whatever they want. Ungood. So let&#39;s fix that. We&#39;ll put the directory inside our home directory under a different users.</p>\n<pre><code class=\"hljs language-dockerfile\"><span class=\"hljs-keyword\">FROM</span> node:<span class=\"hljs-number\">20</span>\n\n<span class=\"hljs-keyword\">USER</span> node\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> index.js /home/node/code/index.js</span>\n\n<span class=\"hljs-keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"hljs-string\">&quot;node&quot;</span>, <span class=\"hljs-string\">&quot;/home/node/code/index.js&quot;</span>]</span>\n</code></pre><p>The <code>USER</code> instruction let&#39;s us switch from being the root user to a different user, one called &quot;node&quot; which the <code>node:20</code> image has already made for us. We could make our own user too using bash commands but let&#39;s just use the one the node image gave us. (More or less you&#39;d run <code>RUN useradd -ms /bin/bash lolcat</code> to add a lolcat user.)</p>\n<p>Notice we&#39;re now copying inside of the user&#39;s home directory. This is because they&#39;ll have proper permissions to interact with those files whereas they may not if we were outside of their home directory. You&#39;ll save yourself a lot of permission wrangling if you put it in a home directory. But we&#39;ll have to add a flag to the <code>COPY</code> command to make sure the user owns those files. We&#39;ll do that with <code>--chown=node:node</code> where the first <code>node</code> is the user and the second <code>node</code> is the user group.</p>\n<p>It&#39;s no big deal that the &quot;code&quot; directory doesn&#39;t exist, <code>COPY</code> will create it.</p>\n<h3>A Quick Note on COPY vs ADD</h3>\n<p>The two commands <code>COPY</code> and <code>ADD</code> do very similar things with a few key differences. <code>ADD</code> can also accept, in addition to local files, URLs to download things off the Internet and it will also automatically unzip any tar files it downloads or adds. <code>COPY</code> will just copy local files. Use <code>COPY</code> unless you need to unzip something or are downloading something.</p>\n<hr>\n<p>Great. Let&#39;s make everything a bit more succint by setting a working directory</p>\n<pre><code class=\"hljs language-dockerfile\"><span class=\"hljs-keyword\">FROM</span> node:<span class=\"hljs-number\">20</span>\n\n<span class=\"hljs-keyword\">USER</span> node\n\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"language-bash\"> /home/node/code</span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> --<span class=\"hljs-built_in\">chown</span>=node:node index.js .</span>\n\n<span class=\"hljs-keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"hljs-string\">&quot;node&quot;</span>, <span class=\"hljs-string\">&quot;index.js&quot;</span>]</span>\n</code></pre><p><a href=\"https://github.com/btholt/project-files-for-complete-intro-to-containers-v2/blob/main/build-a-nodejs-app/better.Dockerfile\">⛓️ Link to Dockerfile</a></p>\n<p><code>WORKDIR</code> works as if you had <code>cd</code>&#39;d into that directory, so now all paths are relative to that. And again, if it doesn&#39;t exist, it will create it for you.</p>\n<p>Now we just tell <code>COPY</code> to copy the file into the same directory. Now we&#39;re giving it a directory instead of a file name, it&#39;ll just assume we want the same name. You could rename it here if you wanted.</p>\n","markdown":"\nSo now let's dig into some more advance things you can do with a Dockerfile. Let's first make our project a real Node.js application. Make a file called `index.js` and put this in there.\n\n```javascript\nconst http = require(\"http\");\n\nhttp\n  .createServer(function (request, response) {\n    console.log(\"request received\");\n    response.end(\"omg hi\", \"utf-8\");\n  })\n  .listen(3000);\nconsole.log(\"server started\");\n```\n\n[⛓️ Link to Node.js file][node-file]\n\nThis more-or-less that most barebones Node.js app you can write. It just responds to HTTP traffic on port 3000. Go ahead and try running it on your local computer (outside of Docker) by running `node index.js`. Open [localhost:3000][localhost] in your browser to give it a shot.\n\nOkay, so let's get this running _inside_ Docker now. First thing is we have to copy this file from your local file system into the container. We'll use a new instruction, `COPY`. Modify your Dockerfile to say:\n\n```dockerfile\nFROM node:20\n\nCOPY index.js index.js\n\nCMD [\"node\", \"index.js\"]\n```\n\n[⛓️ Link to Dockerfile][dockerfile-1]\n\nThis will copy your index.js file from your file system into the Docker file system (the first index.js is the source and the second index.js is the destination of that file inside the container.)\n\nWe then modified the `CMD` to start the server when we finally do run the container. Now run\n\n```bash\ndocker build -t my-node-app .\ndocker run --name my-app --rm my-node-app\n```\n\nYou might need to open another terminal and type `docker kill my-app`.\n\nNow your Node.js app is running inside of a container managed by Docker! Hooray! But one problem, how do we access it? If you open [locahlost:3000][localhost] now, it doesn't work! We have to tell Docker to expose the port. So let's do that now. Stop your container from running and run it again like this.\n\nTry stopping your server now. Your normal CTRL+C won't work. Node.js itself doesn't handle SIGINT (which is what CTRL+C is) in and of itself. Instead you either have to handle it yourself inside of your Node.js code (preferable for real apps) or you can tell Docker to handle it with the `--init` flag. This uses a package called [tini][tini] to handle shutdown signal for you.\n\n```bash\ndocker run --init --publish 3000:3000 --rm my-node-app # or you can use -p instead of --publish\n```\n\nThe `publish` part allows you to forward a port out of a container to the host computer. In this case we're forwarding the port of `3000` (which is what the Node.js server was listening on) to port `3000` on the host machine. The `3000` represents the port on the host machine and the second `3000` represents what port is being used in the container. If you did `docker run --publish 8000:3000 my-node-app`, you'd open `localhost:8000` to see the server (running on port `3000` inside the container).\n\nNext, let's organize ourselves a bit better. Right now we're putting our app into the root directory of our container and running it as the root user. This both messy and unsafe. If there's an exploit for Node.js that get released, it means that whoever uses that exploit on our Node.js server will doing so as root which means they can do whatever they want. Ungood. So let's fix that. We'll put the directory inside our home directory under a different users.\n\n```dockerfile\nFROM node:20\n\nUSER node\n\nCOPY index.js /home/node/code/index.js\n\nCMD [\"node\", \"/home/node/code/index.js\"]\n```\n\nThe `USER` instruction let's us switch from being the root user to a different user, one called \"node\" which the `node:20` image has already made for us. We could make our own user too using bash commands but let's just use the one the node image gave us. (More or less you'd run `RUN useradd -ms /bin/bash lolcat` to add a lolcat user.)\n\nNotice we're now copying inside of the user's home directory. This is because they'll have proper permissions to interact with those files whereas they may not if we were outside of their home directory. You'll save yourself a lot of permission wrangling if you put it in a home directory. But we'll have to add a flag to the `COPY` command to make sure the user owns those files. We'll do that with `--chown=node:node` where the first `node` is the user and the second `node` is the user group.\n\nIt's no big deal that the \"code\" directory doesn't exist, `COPY` will create it.\n\n### A Quick Note on COPY vs ADD\n\nThe two commands `COPY` and `ADD` do very similar things with a few key differences. `ADD` can also accept, in addition to local files, URLs to download things off the Internet and it will also automatically unzip any tar files it downloads or adds. `COPY` will just copy local files. Use `COPY` unless you need to unzip something or are downloading something.\n\n---\n\nGreat. Let's make everything a bit more succint by setting a working directory\n\n```dockerfile\nFROM node:20\n\nUSER node\n\nWORKDIR /home/node/code\n\nCOPY --chown=node:node index.js .\n\nCMD [\"node\", \"index.js\"]\n```\n\n[⛓️ Link to Dockerfile][dockerfile-2]\n\n`WORKDIR` works as if you had `cd`'d into that directory, so now all paths are relative to that. And again, if it doesn't exist, it will create it for you.\n\nNow we just tell `COPY` to copy the file into the same directory. Now we're giving it a directory instead of a file name, it'll just assume we want the same name. You could rename it here if you wanted.\n\n[localhost]: http://localhost:3000\n[tini]: https://github.com/krallin/tini\n[node-file]: https://github.com/btholt/project-files-for-complete-intro-to-containers-v2/blob/main/build-a-nodejs-app/index.js\n[dockerfile-1]: https://github.com/btholt/project-files-for-complete-intro-to-containers-v2/blob/main/build-a-nodejs-app/Dockerfile\n[dockerfile-2]: https://github.com/btholt/project-files-for-complete-intro-to-containers-v2/blob/main/build-a-nodejs-app/better.Dockerfile\n","slug":"build-a-nodejs-app","title":"Build a Node.js App","section":"Dockerfiles","icon":"file-lines","filePath":"/home/runner/work/complete-intro-to-containers-v2/complete-intro-to-containers-v2/lessons/04-dockerfiles/B-build-a-nodejs-app.md","nextSlug":"/lessons/dockerfiles/build-a-more-complicated-nodejs-app","prevSlug":"/lessons/dockerfiles/intro-to-dockerfiles"}},"__N_SSG":true}