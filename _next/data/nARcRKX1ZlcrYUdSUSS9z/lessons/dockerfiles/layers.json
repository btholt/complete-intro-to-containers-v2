{"pageProps":{"post":{"attributes":{"description":"Learn how Docker optimizes build processes by reusing cached layers and rebuilding only what has changed, like with the COPY instruction. Discover strategies to speed up container-building, such as breaking COPY into multiple instructions for efficient npm ci runs in Node.js applications.","keywords":["Docker optimization","container building","npm ci optimization","speed up Docker builds"]},"html":"<p>Go make any change to your Node.js app. Now re-run your build process. Docker is smart enough to see the your <code>FROM</code>, <code>RUN</code>, and <code>WORKDIR</code> instructions haven&#39;t changed and wouldn&#39;t change if you ran them again so it uses the same layers it cached from the previous but it can see that your <code>COPY</code> is different since files changed between last time and this time, so it begins the build process there and re-runs all instructions after that. Pretty smart, right? This is the same mechanism that Docker uses when you pull a new container to download it in pieces. Each one of those corresponds to a layer.</p>\n<p>So which part of container-building takes the longest? <code>RUN npm ci</code>. Anything that has to hit the network is going to take the longest without-a-doubt. The shame is that our <code>package.json</code> hasn&#39;t changed since the previous iteration; we just changed something in our <code>index.js</code>. So how we make it so we only re-run our <code>npm ci</code> when package.json changes? Break it into two <code>COPY</code> instructions!</p>\n<pre><code class=\"hljs language-Dockerfile\"><span class=\"hljs-keyword\">FROM</span> node:<span class=\"hljs-number\">20</span>\n\n<span class=\"hljs-keyword\">USER</span> node\n\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> <span class=\"hljs-built_in\">mkdir</span> /home/node/code</span>\n\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"language-bash\"> /home/node/code</span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> --<span class=\"hljs-built_in\">chown</span>=node:node package-lock.json package.json ./</span>\n\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> npm ci</span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> --<span class=\"hljs-built_in\">chown</span>=node:node . .</span>\n\n<span class=\"hljs-keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"hljs-string\">&quot;node&quot;</span>, <span class=\"hljs-string\">&quot;index.js&quot;</span>]</span>\n</code></pre><p><a href=\"https://github.com/btholt/project-files-for-complete-intro-to-containers-v2/blob/main/layers/Dockerfile\">⛓️ Link to the Dockerfile</a></p>\n<pre><code class=\"hljs language-bash\">docker build -t layers .\ndocker run -it -p 8080:8080 --name my-app --<span class=\"hljs-built_in\">rm</span> --init layers\n</code></pre><p>The first <code>COPY</code> pulls just the <code>package.json</code> and the <code>package-lock.json</code> which is just enough to do the <code>npm ci</code>. After that we nab the rest of the files. Now if you make changes you avoid doing a full npm install. This is useful and recommended for any dependency installation: apt-get, pip, cargo, gems, etc. as well as any long-running command like building some from source.</p>\n","markdown":"\nGo make any change to your Node.js app. Now re-run your build process. Docker is smart enough to see the your `FROM`, `RUN`, and `WORKDIR` instructions haven't changed and wouldn't change if you ran them again so it uses the same layers it cached from the previous but it can see that your `COPY` is different since files changed between last time and this time, so it begins the build process there and re-runs all instructions after that. Pretty smart, right? This is the same mechanism that Docker uses when you pull a new container to download it in pieces. Each one of those corresponds to a layer.\n\nSo which part of container-building takes the longest? `RUN npm ci`. Anything that has to hit the network is going to take the longest without-a-doubt. The shame is that our `package.json` hasn't changed since the previous iteration; we just changed something in our `index.js`. So how we make it so we only re-run our `npm ci` when package.json changes? Break it into two `COPY` instructions!\n\n```Dockerfile\nFROM node:20\n\nUSER node\n\nRUN mkdir /home/node/code\n\nWORKDIR /home/node/code\n\nCOPY --chown=node:node package-lock.json package.json ./\n\nRUN npm ci\n\nCOPY --chown=node:node . .\n\nCMD [\"node\", \"index.js\"]\n```\n\n[⛓️ Link to the Dockerfile][dockerfile-file]\n\n```bash\ndocker build -t layers .\ndocker run -it -p 8080:8080 --name my-app --rm --init layers\n```\n\nThe first `COPY` pulls just the `package.json` and the `package-lock.json` which is just enough to do the `npm ci`. After that we nab the rest of the files. Now if you make changes you avoid doing a full npm install. This is useful and recommended for any dependency installation: apt-get, pip, cargo, gems, etc. as well as any long-running command like building some from source.\n\n[dockerfile-file]: https://github.com/btholt/project-files-for-complete-intro-to-containers-v2/blob/main/layers/Dockerfile\n","slug":"layers","title":"Layers","section":"Dockerfiles","icon":"file-lines","filePath":"/home/runner/work/complete-intro-to-containers-v2/complete-intro-to-containers-v2/lessons/04-dockerfiles/E-layers.md","nextSlug":"/lessons/making-tiny-containers/alpine-linux","prevSlug":"/lessons/dockerfiles/a-note-on-expose"}},"__N_SSG":true}