{"pageProps":{"post":{"attributes":{"description":"Learn how to use Docker Compose to coordinate multiple containers for development environments efficiently. Simplify defining relationships between containers using a YAML file, making it easy to manage complex setups with one command. Explore CI/CD integration possibilities and enhance development productivity by leveraging Docker Compose features.","keywords":["Docker Compose","multiple containers","development environments","CI/CD scenarios","YAML file","containers relationship","productivity"]},"html":"<p>This may be one of the most useful features you learn about Docker. We&#39;ve been mixing various different facets of deploying your app to production and creating development environments. This feature in particular is geared much more for development environments. Many times when you&#39;re developing containers you&#39;re not in just a single container environment (though that does happen too.) When this happens, you need to coordinate multiple containers when you&#39;re doing local dev and you&#39;ve seen in the previous chapter, networking, that it&#39;s possible if a bit annoying.</p>\n<p>With Docker Compose we simplify this a lot. Docker Compose allows us the ability to coordinate multiple containers and do so with one YAML file. This is great if you&#39;re developing a Node.js app and it requires a database, caching, or even if you have two+ separate apps in two+ separate containers that depend on each other or all the above! Docker Compose makes it really simple to define the relationship between these containers and get them all running with one <code>docker compose up</code>.</p>\n<blockquote>\n<p>If you see any commands out there with <code>docker-compose</code> (key being the <code>-</code> in there) it&#39;s from Docker Compose v1 which is not supported anymore. We are using Docker Compose v2 here. For our purposes there isn&#39;t much difference.</p>\n</blockquote>\n<p>Do note that Docker does say that Docker Compose is suitable for production environments if you have a single instance running multiple containers. This is atypical for the most part: if you have multiple containers, typically you want the ability to have many instances.</p>\n<p>In addition to working very well dev, Docker Compose is very useful in CI/CD scenarios when you want GitHub Actions or some CI/CD provider to spin up multiple environments to quickly run some tests.</p>\n<p>Okay so let&#39;s get our previous app working: the one with a MongoDB database being connected to by a Node.js app. Create a new file in the root directory of your project called <code>docker-compose.yml</code> and put this in there:</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-attr\">services:</span>\n  <span class=\"hljs-attr\">api:</span>\n    <span class=\"hljs-attr\">build:</span> <span class=\"hljs-string\">api</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;8080:8080&quot;</span>\n    <span class=\"hljs-attr\">links:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">db</span>\n    <span class=\"hljs-attr\">environment:</span>\n      <span class=\"hljs-attr\">MONGO_CONNECTION_STRING:</span> <span class=\"hljs-string\">mongodb://db:27017</span>\n  <span class=\"hljs-attr\">db:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">mongo:7</span>\n  <span class=\"hljs-attr\">web:</span>\n    <span class=\"hljs-attr\">build:</span> <span class=\"hljs-string\">web</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;8081:80&quot;</span>\n</code></pre><p>This should feel familiar even if it&#39;s new to you. This is basically all of the CLI configurations we were giving to the two containers but captured in a YAML file.</p>\n<p>In <code>service</code> we define the containers we need for this particular app. We have two: the <code>web</code> container (which is our app) and the <code>db</code> container which is MongoDB. We then identify where the Dockerfile is with <code>build</code>, which ports to expose in <code>ports</code>, and the <code>environment</code> variables using that field.</p>\n<p>The one interesting one here is the <code>links</code> field. In this one we&#39;re saying that the <code>api</code> container needs to be connected to the <code>db</code> container. This means Docker will start this container first and then network it to the <code>api</code> container. This works the same way as what we were doing in the previous lesson.</p>\n<p>The <code>db</code> container is pretty simple: it&#39;s just the <code>mongo</code> container from Docker Hub. This is actually smart enough to expose 27017 as the port and to make a volume to keep the data around between restarts so we don&#39;t actually have to do anything for that. If you needed any other containers, you&#39;d just put them here in services.</p>\n<p>We then have a frontend React.js app that is being built by Parcel.js and served by NGINX.</p>\n<p>There&#39;s a lot more to compose files than what I&#39;ve shown you here but I&#39;ll let you explore that on your own time. <a href=\"https://docs.docker.com/compose/compose-file/#compose-file-structure-and-examples\">Click here</a> to see the docs to see what else is possible.</p>\n<p>This will start and work now, just run <code>docker compose up</code> and it&#39;ll get going. I just want to do one thing: let&#39;s make our app even more productive to develop on. Go to your Dockerfile for the app make it read a such:</p>\n<blockquote>\n<p>If you change something and want to make sure it builds, make sure to run <code>docker compose up --build</code>. Docker Compose isn&#39;t watching for changes when you run up.</p>\n</blockquote>\n<pre><code class=\"hljs language-dockerfile\"><span class=\"hljs-keyword\">FROM</span> node:latest\n\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> npm i -g nodemon</span>\n\n<span class=\"hljs-keyword\">USER</span> node\n\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> <span class=\"hljs-built_in\">mkdir</span> /home/node/code</span>\n\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"language-bash\"> /home/node/code</span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> --<span class=\"hljs-built_in\">chown</span>=node:node package-lock.json package.json ./</span>\n\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> npm ci</span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> --<span class=\"hljs-built_in\">chown</span>=node:node . .</span>\n\n<span class=\"hljs-keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"hljs-string\">&quot;nodemon&quot;</span>, <span class=\"hljs-string\">&quot;index.js&quot;</span>]</span>\n</code></pre><p>Now we can write our code and every time it save it&#39;ll restart the server from within the container. This will make this super productive to work with!</p>\n<p>While we&#39;re about to get to Kubernetes which will handle bigger deployment scenarios than Docker Compose can, you can use <code>docker-compose up --scale web=10</code> to scale up your web container to 10 concurrently running containers. This won&#39;t work at the moment because they&#39;re all trying to listen on the host on port 3000 but we could use something like NGINX or HAProxy to loadbalance amongst the containers. It&#39;s a bit more advance use case and less useful for Compose since at that point you should probably just use Kubernetes or something similar. We&#39;ll approach it in the Kubernetes chapter.</p>\n","markdown":"\nThis may be one of the most useful features you learn about Docker. We've been mixing various different facets of deploying your app to production and creating development environments. This feature in particular is geared much more for development environments. Many times when you're developing containers you're not in just a single container environment (though that does happen too.) When this happens, you need to coordinate multiple containers when you're doing local dev and you've seen in the previous chapter, networking, that it's possible if a bit annoying.\n\nWith Docker Compose we simplify this a lot. Docker Compose allows us the ability to coordinate multiple containers and do so with one YAML file. This is great if you're developing a Node.js app and it requires a database, caching, or even if you have two+ separate apps in two+ separate containers that depend on each other or all the above! Docker Compose makes it really simple to define the relationship between these containers and get them all running with one `docker compose up`.\n\n> If you see any commands out there with `docker-compose` (key being the `-` in there) it's from Docker Compose v1 which is not supported anymore. We are using Docker Compose v2 here. For our purposes there isn't much difference.\n\nDo note that Docker does say that Docker Compose is suitable for production environments if you have a single instance running multiple containers. This is atypical for the most part: if you have multiple containers, typically you want the ability to have many instances.\n\nIn addition to working very well dev, Docker Compose is very useful in CI/CD scenarios when you want GitHub Actions or some CI/CD provider to spin up multiple environments to quickly run some tests.\n\nOkay so let's get our previous app working: the one with a MongoDB database being connected to by a Node.js app. Create a new file in the root directory of your project called `docker-compose.yml` and put this in there:\n\n```yml\nservices:\n  api:\n    build: api\n    ports:\n      - \"8080:8080\"\n    links:\n      - db\n    environment:\n      MONGO_CONNECTION_STRING: mongodb://db:27017\n  db:\n    image: mongo:7\n  web:\n    build: web\n    ports:\n      - \"8081:80\"\n```\n\nThis should feel familiar even if it's new to you. This is basically all of the CLI configurations we were giving to the two containers but captured in a YAML file.\n\nIn `service` we define the containers we need for this particular app. We have two: the `web` container (which is our app) and the `db` container which is MongoDB. We then identify where the Dockerfile is with `build`, which ports to expose in `ports`, and the `environment` variables using that field.\n\nThe one interesting one here is the `links` field. In this one we're saying that the `api` container needs to be connected to the `db` container. This means Docker will start this container first and then network it to the `api` container. This works the same way as what we were doing in the previous lesson.\n\nThe `db` container is pretty simple: it's just the `mongo` container from Docker Hub. This is actually smart enough to expose 27017 as the port and to make a volume to keep the data around between restarts so we don't actually have to do anything for that. If you needed any other containers, you'd just put them here in services.\n\nWe then have a frontend React.js app that is being built by Parcel.js and served by NGINX.\n\nThere's a lot more to compose files than what I've shown you here but I'll let you explore that on your own time. [Click here][compose] to see the docs to see what else is possible.\n\nThis will start and work now, just run `docker compose up` and it'll get going. I just want to do one thing: let's make our app even more productive to develop on. Go to your Dockerfile for the app make it read a such:\n\n> If you change something and want to make sure it builds, make sure to run `docker compose up --build`. Docker Compose isn't watching for changes when you run up.\n\n```dockerfile\nFROM node:latest\n\nRUN npm i -g nodemon\n\nUSER node\n\nRUN mkdir /home/node/code\n\nWORKDIR /home/node/code\n\nCOPY --chown=node:node package-lock.json package.json ./\n\nRUN npm ci\n\nCOPY --chown=node:node . .\n\nCMD [\"nodemon\", \"index.js\"]\n```\n\nNow we can write our code and every time it save it'll restart the server from within the container. This will make this super productive to work with!\n\nWhile we're about to get to Kubernetes which will handle bigger deployment scenarios than Docker Compose can, you can use `docker-compose up --scale web=10` to scale up your web container to 10 concurrently running containers. This won't work at the moment because they're all trying to listen on the host on port 3000 but we could use something like NGINX or HAProxy to loadbalance amongst the containers. It's a bit more advance use case and less useful for Compose since at that point you should probably just use Kubernetes or something similar. We'll approach it in the Kubernetes chapter.\n\n[compose]: https://docs.docker.com/compose/compose-file/#compose-file-structure-and-examples\n","slug":"docker-compose","title":"Docker Compose","section":"Multi Container Projects","icon":"boxes-stacked","filePath":"/home/runner/work/complete-intro-to-containers-v2/complete-intro-to-containers-v2/lessons/07-multi-container-projects/A-docker-compose.md","nextSlug":"/lessons/multi-container-projects/kubernetes","prevSlug":"/lessons/docker-features/networking-with-docker"}},"__N_SSG":true}