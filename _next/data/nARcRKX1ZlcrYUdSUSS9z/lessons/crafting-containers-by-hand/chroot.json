{"pageProps":{"post":{"attributes":{"title":"chroot","description":"Learn how to use the Linux `chroot` command within containers to set a new root directory, isolating processes for enhanced security. Follow a step-by-step guide to create a new environment, copy necessary libraries, and successfully run commands within the isolated space.","keywords":["Linux chroot command","container security","isolating processes","copying libraries in chroot","Ubuntu Docker container","setting new root directory"]},"html":"<p>I&#39;ve heard people call this &quot;cha-root&quot; and &quot;change root&quot;. I&#39;m going to stick to &quot;change root&quot; because I feel less ridiculous saying that. It&#39;s a Linux command that allows you to set the root directory of a new process. In our container use case, we just set the root directory to be where-ever the new container&#39;s new root directory should be. And now the new container group of processes can&#39;t see anything outside of it, eliminating our security problem because the new process has no visibility outside of its new root.</p>\n<p>Let&#39;s try it. Start up a Ubuntu VM however you feel most comfortable. I&#39;ll be using Docker (and doing containers within containers ü§Ø). If you&#39;re like me, run <code>docker run -it --name docker-host --rm --privileged ubuntu:jammy</code>. This will download the <a href=\"https://hub.docker.com/_/ubuntu\">official Ubuntu container</a> from Docker Hub and grab the version marked with the <em>jammy</em> tag. In this case, <em>latest</em> means it&#39;s the latest stable release (22.04.) You could put <code>ubuntu:devel</code> to get the latest development of Ubuntu (as of writing that&#39;d be 24.04). <code>docker run</code> means we&#39;re going to run some commands in the container, and the <code>-it</code> means we want to make the shell interactive (so we can use it like a normal terminal.)</p>\n<p>If you&#39;re in Windows and using WSL, just open a new WSL terminal in Ubuntu. ‚úåÔ∏è</p>\n<p>To see what version of Ubuntu you&#39;re using, run <code>cat /etc/issue</code>. <code>cat</code> reads a file and dumps it into the output which means we can read it, and <code>/etc/issue</code> is a file that will tell us what distro we&#39;re using. Mine says <code>Ubuntu 22.04.4 LTS \\n \\l</code>.</p>\n<p>Okay, so let&#39;s attempt to use <code>chroot</code> right now.</p>\n<ol>\n<li>Make a new folder in your root directory via <code>mkdir /my-new-root</code>.</li>\n<li>Inside that new folder, run <code>echo &quot;my super secret thing&quot; &gt;&gt; /my-new-root/secret.txt</code>.</li>\n<li>Now try to run <code>chroot /my-new-root bash</code> and see the error it gives you.</li>\n</ol>\n<p>You should see something about failing to run a shell or not being able to find bash. That&#39;s because bash is a program and your new root wouldn&#39;t have bash to run (because it can&#39;t reach outside of its new root.) So let&#39;s fix that! Run:</p>\n<ol>\n<li><code>mkdir /my-new-root/bin</code></li>\n<li><code>cp /bin/bash /bin/ls /my-new-root/bin/</code></li>\n<li><code>chroot /my-new-root bash</code></li>\n</ol>\n<p>Still not working! The problem is that these commands rely on libraries to power them and we didn&#39;t bring those with us. So let&#39;s do that too. Run <code>ldd /bin/bash</code>. This print out something like this:</p>\n<pre><code class=\"hljs language-bash\">$ ldd /bin/bash\n    linux-vdso.so.1 (0x0000ffffbe221000)\n    libtinfo.so.6 =&gt; /lib/aarch64-linux-gnu/libtinfo.so.6 (0x0000ffffbe020000)\n    libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6 (0x0000ffffbde70000)\n    /lib/ld-linux-aarch64.so.1 (0x0000ffffbe1e8000)\n</code></pre><p>These are the libraries we need for bash. Let&#39;s go ahead and copy those into our new environment.</p>\n<ol>\n<li><code>mkdir /my-new-root/lib</code></li>\n<li>Then we need to copy all those paths (ignore the lines that don&#39;t have paths) into our directory. Make sure you get the right files in the right directory. In my case above (yours likely will be different) it&#39;s:<ol>\n<li><code>cp /lib/aarch64-linux-gnu/libtinfo.so.6 /lib/aarch64-linux-gnu/libc.so.6 /lib/ld-linux-aarch64.so.1 /my-new-root/lib</code></li>\n</ol>\n</li>\n<li>Do it again for <code>ls</code>. Run <code>ldd /bin/ls</code></li>\n<li>Follow the same process to copy the libraries for <code>ls</code> into our <code>my-new-root</code>.<ol>\n<li><code>cp  /lib/aarch64-linux-gnu/libselinux.so.1 /lib/aarch64-linux-gnu/libc.so.6 /lib/ld-linux-aarch64.so.1 /lib/aarch64-linux-gnu/libpcre2-8.so.0 /my-new-root/lib</code></li>\n</ol>\n</li>\n</ol>\n<p>Now, finally, run <code>chroot /my-new-root bash</code> and run <code>ls</code>. You should successfully see everything in the directory. Now try <code>pwd</code> to see your working directory. You should see <code>/</code>. You can&#39;t get out of here! This, before being called containers, was called a jail for this reason. At any time, hit CTRL+D or run <code>exit</code> to get out of your chrooted environment.</p>\n<h2>cat exercise</h2>\n<p>Now try running <code>cat secret.txt</code>. Oh no! Your new chroot-ed environment doesn&#39;t know how to cat! As an exercise, go make <code>cat</code> work the same way we did above!</p>\n<p>Congrats you just cha-rooted the **** out of your first environment!</p>\n","markdown":"\nI've heard people call this \"cha-root\" and \"change root\". I'm going to stick to \"change root\" because I feel less ridiculous saying that. It's a Linux command that allows you to set the root directory of a new process. In our container use case, we just set the root directory to be where-ever the new container's new root directory should be. And now the new container group of processes can't see anything outside of it, eliminating our security problem because the new process has no visibility outside of its new root.\n\nLet's try it. Start up a Ubuntu VM however you feel most comfortable. I'll be using Docker (and doing containers within containers ü§Ø). If you're like me, run `docker run -it --name docker-host --rm --privileged ubuntu:jammy`. This will download the [official Ubuntu container][ubuntu] from Docker Hub and grab the version marked with the _jammy_ tag. In this case, _latest_ means it's the latest stable release (22.04.) You could put `ubuntu:devel` to get the latest development of Ubuntu (as of writing that'd be 24.04). `docker run` means we're going to run some commands in the container, and the `-it` means we want to make the shell interactive (so we can use it like a normal terminal.)\n\nIf you're in Windows and using WSL, just open a new WSL terminal in Ubuntu. ‚úåÔ∏è\n\nTo see what version of Ubuntu you're using, run `cat /etc/issue`. `cat` reads a file and dumps it into the output which means we can read it, and `/etc/issue` is a file that will tell us what distro we're using. Mine says `Ubuntu 22.04.4 LTS \\n \\l`.\n\nOkay, so let's attempt to use `chroot` right now.\n\n1. Make a new folder in your root directory via `mkdir /my-new-root`.\n1. Inside that new folder, run `echo \"my super secret thing\" >> /my-new-root/secret.txt`.\n1. Now try to run `chroot /my-new-root bash` and see the error it gives you.\n\nYou should see something about failing to run a shell or not being able to find bash. That's because bash is a program and your new root wouldn't have bash to run (because it can't reach outside of its new root.) So let's fix that! Run:\n\n1. `mkdir /my-new-root/bin`\n1. `cp /bin/bash /bin/ls /my-new-root/bin/`\n1. `chroot /my-new-root bash`\n\nStill not working! The problem is that these commands rely on libraries to power them and we didn't bring those with us. So let's do that too. Run `ldd /bin/bash`. This print out something like this:\n\n```bash\n$ ldd /bin/bash\n\tlinux-vdso.so.1 (0x0000ffffbe221000)\n\tlibtinfo.so.6 => /lib/aarch64-linux-gnu/libtinfo.so.6 (0x0000ffffbe020000)\n\tlibc.so.6 => /lib/aarch64-linux-gnu/libc.so.6 (0x0000ffffbde70000)\n\t/lib/ld-linux-aarch64.so.1 (0x0000ffffbe1e8000)\n```\n\nThese are the libraries we need for bash. Let's go ahead and copy those into our new environment.\n\n1. `mkdir /my-new-root/lib`\n1. Then we need to copy all those paths (ignore the lines that don't have paths) into our directory. Make sure you get the right files in the right directory. In my case above (yours likely will be different) it's:\n   1. `cp /lib/aarch64-linux-gnu/libtinfo.so.6 /lib/aarch64-linux-gnu/libc.so.6 /lib/ld-linux-aarch64.so.1 /my-new-root/lib`\n1. Do it again for `ls`. Run `ldd /bin/ls`\n1. Follow the same process to copy the libraries for `ls` into our `my-new-root`.\n   1. `cp  /lib/aarch64-linux-gnu/libselinux.so.1 /lib/aarch64-linux-gnu/libc.so.6 /lib/ld-linux-aarch64.so.1 /lib/aarch64-linux-gnu/libpcre2-8.so.0 /my-new-root/lib`\n\nNow, finally, run `chroot /my-new-root bash` and run `ls`. You should successfully see everything in the directory. Now try `pwd` to see your working directory. You should see `/`. You can't get out of here! This, before being called containers, was called a jail for this reason. At any time, hit CTRL+D or run `exit` to get out of your chrooted environment.\n\n## cat exercise\n\nNow try running `cat secret.txt`. Oh no! Your new chroot-ed environment doesn't know how to cat! As an exercise, go make `cat` work the same way we did above!\n\nCongrats you just cha-rooted the \\*\\*\\*\\* out of your first environment!\n\n[ubuntu]: https://hub.docker.com/_/ubuntu\n","slug":"chroot","title":"chroot","section":"Crafting Containers by Hand","icon":"hand-holding-heart","filePath":"/home/runner/work/complete-intro-to-containers-v2/complete-intro-to-containers-v2/lessons/02-crafting-containers-by-hand/B-chroot.md","nextSlug":"/lessons/crafting-containers-by-hand/namespaces","prevSlug":"/lessons/crafting-containers-by-hand/what-are-containers"}},"__N_SSG":true}