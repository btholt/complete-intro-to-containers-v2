{"pageProps":{"post":{"attributes":{"description":"Learn about using volumes and bind mounts in Docker containers to handle stateful operations, along with the differences between them. Bind mounts enable flexible file access between the host computer and container, offering a practical solution for testing or development scenarios.","keywords":["Docker","volumes","bind mounts","stateful containers","containerization","NGINX","Dockerfile"]},"html":"<p>So far we&#39;ve been dealing with self-contained containers. Normally this is all you ever want: containers that can spin up and spin down as frequently as they need to. They&#39;re ephemeral, temporary, and disposable. None of these containers are &quot;snowflakes&quot;. When I say snowflakes, picture you&#39;re running a server that&#39;s serving a Wordpress site. Imagine setting up this server, SSH&#39;ing into the server, and setting everything up to be just right and tuned to the exact way you need it. This would be a snowflake server: if someone goes and deletes this server, you&#39;re screwed. You have to go and spend a bunch of time re-setting up this server. This is exactly the sort of thing we&#39;re trying to avoid with containers. These are the &quot;pet&quot; containers we talked about earlier. We want to make our servers easy to reproduce whenever we want so we can spin up and spin down servers at will. These are the &quot;cattle&quot; containers we talked about.</p>\n<p>However not everything can fit neatly into a container all the time. Sometimes our containers need to be stateful in some capacity. Sometimes our containers need to read and write to the host. This is fundamentally at odds with the idea of a stateless, able-to-create-and-destroy-anytime container that we&#39;ve been adhering to thusfar. So what are we to do?</p>\n<p>Enter volumes and bind mounts. Both of these are methods of reading and writing to the host but with slight-but-important differences of when to use which. We&#39;ll go over both.</p>\n<h2>Bind Mounts</h2>\n<p>Let&#39;s start here because this is easier to see the use case for. Bind mounts allow you to mount files from your host computer into your container. This allows you to use the containers a much more flexible way than previously possible: you don&#39;t have to know what files the container will have <em>when you build it</em> and it allows you to determine those files <em>when you run it</em>.</p>\n<p>Let&#39;s go over an example of how this could be useful.</p>\n<p>In the previous project, we used the NGINX image to build a container with our static assets baked into the container. In general this what I recommend you do since now we can ship that container anywhere and it&#39;ll just work. It&#39;s totally self-contained. But what if we just want to run a NGINX container locally to test stuff out? Sure, we could make a new Dockerfile and write it, but wouldn&#39;t it be cool if we could just use the NGINX container directly? We can! Let&#39;s try it. Go back to your static site project from the previous lesson. Let&#39;s use the <code>nginx</code> container to serve directly from it.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># from the root directory of your Astro app</span>\ndocker run --mount <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-built_in\">bind</span>,<span class=\"hljs-built_in\">source</span>=<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(pwd)</span>&quot;</span>/dist,target=/usr/share/nginx/html -p 8080:80 nginx:latest\n</code></pre><p><a href=\"https://github.com/btholt/project-files-for-complete-intro-to-containers-v2/blob/main/static-asset-project\">⛓️ Link to the Project</a> (run the docker command from this directory)</p>\n<blockquote>\n<p>Make sure you have built the project. If you did the previous lesson you should have this already built. If you don&#39;t see the <code>dist/</code> directory, run <code>npm install &amp;&amp; npm run build</code>. You should see the <code>dist</code> directory after that.</p>\n</blockquote>\n<p>This is how you do bind mounts. It&#39;s a bit verbose but necessary. Let&#39;s dissect it.</p>\n<ul>\n<li>We use the <code>--mount</code> flag to identify we&#39;re going to be mounting something in from the host.</li>\n<li>As far as I know the only two types are <code>bind</code> and <code>volume</code>. Here we&#39;re using bind because we to mount in some piece of already existing data from the host.</li>\n<li>In the source, we identify what part of the host we want to make readable-and-writable to the container. It has to be an absolute path (e.g we can&#39;t say <code>&quot;./dist&quot;</code>) which is why use the <code>&quot;$(pwd)&quot;</code> to get the <strong>p</strong>resent <strong>w</strong>orking <strong>d</strong>irectory to make it an absolute path.</li>\n<li>The target is where we want those files to be mounted in the container. Here we&#39;re putting it in the spot that NGINX is expecting.</li>\n<li>As a side note, you can mount as many mounts as you care to, and you mix bind and volume mounts. NGINX has a default config that we&#39;re using but if we used another bind mount to mount an NGINX config to <code>/etc/nginx/nginx.conf</code> it would use that instead.</li>\n</ul>\n<p>Again, it&#39;s preferable to bake your own container so you don&#39;t have to ship the container and the code separately; you&#39;d rather just ship one thing that you can run without much ritual nor ceremony. But this is a useful trick to have in your pocket. It&#39;s kind of like <a href=\"https://github.com/vercel/serve\">serve</a> but with real NGINX.</p>\n","markdown":"\nSo far we've been dealing with self-contained containers. Normally this is all you ever want: containers that can spin up and spin down as frequently as they need to. They're ephemeral, temporary, and disposable. None of these containers are \"snowflakes\". When I say snowflakes, picture you're running a server that's serving a Wordpress site. Imagine setting up this server, SSH'ing into the server, and setting everything up to be just right and tuned to the exact way you need it. This would be a snowflake server: if someone goes and deletes this server, you're screwed. You have to go and spend a bunch of time re-setting up this server. This is exactly the sort of thing we're trying to avoid with containers. These are the \"pet\" containers we talked about earlier. We want to make our servers easy to reproduce whenever we want so we can spin up and spin down servers at will. These are the \"cattle\" containers we talked about.\n\nHowever not everything can fit neatly into a container all the time. Sometimes our containers need to be stateful in some capacity. Sometimes our containers need to read and write to the host. This is fundamentally at odds with the idea of a stateless, able-to-create-and-destroy-anytime container that we've been adhering to thusfar. So what are we to do?\n\nEnter volumes and bind mounts. Both of these are methods of reading and writing to the host but with slight-but-important differences of when to use which. We'll go over both.\n\n## Bind Mounts\n\nLet's start here because this is easier to see the use case for. Bind mounts allow you to mount files from your host computer into your container. This allows you to use the containers a much more flexible way than previously possible: you don't have to know what files the container will have _when you build it_ and it allows you to determine those files _when you run it_.\n\nLet's go over an example of how this could be useful.\n\nIn the previous project, we used the NGINX image to build a container with our static assets baked into the container. In general this what I recommend you do since now we can ship that container anywhere and it'll just work. It's totally self-contained. But what if we just want to run a NGINX container locally to test stuff out? Sure, we could make a new Dockerfile and write it, but wouldn't it be cool if we could just use the NGINX container directly? We can! Let's try it. Go back to your static site project from the previous lesson. Let's use the `nginx` container to serve directly from it.\n\n```bash\n# from the root directory of your Astro app\ndocker run --mount type=bind,source=\"$(pwd)\"/dist,target=/usr/share/nginx/html -p 8080:80 nginx:latest\n```\n\n[⛓️ Link to the Project][project] (run the docker command from this directory)\n\n> Make sure you have built the project. If you did the previous lesson you should have this already built. If you don't see the `dist/` directory, run `npm install && npm run build`. You should see the `dist` directory after that.\n\nThis is how you do bind mounts. It's a bit verbose but necessary. Let's dissect it.\n\n- We use the `--mount` flag to identify we're going to be mounting something in from the host.\n- As far as I know the only two types are `bind` and `volume`. Here we're using bind because we to mount in some piece of already existing data from the host.\n- In the source, we identify what part of the host we want to make readable-and-writable to the container. It has to be an absolute path (e.g we can't say `\"./dist\"`) which is why use the `\"$(pwd)\"` to get the **p**resent **w**orking **d**irectory to make it an absolute path.\n- The target is where we want those files to be mounted in the container. Here we're putting it in the spot that NGINX is expecting.\n- As a side note, you can mount as many mounts as you care to, and you mix bind and volume mounts. NGINX has a default config that we're using but if we used another bind mount to mount an NGINX config to `/etc/nginx/nginx.conf` it would use that instead.\n\nAgain, it's preferable to bake your own container so you don't have to ship the container and the code separately; you'd rather just ship one thing that you can run without much ritual nor ceremony. But this is a useful trick to have in your pocket. It's kind of like [serve][serve] but with real NGINX.\n\n[storage]: https://docs.docker.com/storage/\n[project]: https://github.com/btholt/project-files-for-complete-intro-to-containers-v2/blob/main/static-asset-project\n[serve]: https://github.com/vercel/serve\n","slug":"bind-mounts","title":"Bind Mounts","section":"Docker Features","icon":"box","filePath":"/home/runner/work/complete-intro-to-containers-v2/complete-intro-to-containers-v2/lessons/06-docker-features/A-bind-mounts.md","nextSlug":"/lessons/docker-features/volumes","prevSlug":"/lessons/making-tiny-containers/static-asset-project"}},"__N_SSG":true}