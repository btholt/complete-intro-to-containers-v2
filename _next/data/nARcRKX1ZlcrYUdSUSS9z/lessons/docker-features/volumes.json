{"pageProps":{"post":{"attributes":{"description":"Learn about the differences between bind mounts and volumes in Docker, how to persist data using volumes for containers, and create a Node.js app with Docker volumes. Understand the benefits of using volumes over bind mounts in Docker for data persistence and manageability.","keywords":["Docker bind mounts vs volumes","persist data in Docker containers","create Node.js app with Docker volumes"]},"html":"<p>Bind mounts are great for when you need to share data between your host and your container as we just learned. Volumes, on the other hand, are so that your containers can maintain state between runs. So if you have a container that runs and the next time it runs it needs the results from the previous time it ran, volumes are going to be helpful. Volumes can not only be shared by the same container-type between runs but also between different containers. Maybe if you have two containers and you want to log to consolidate your logs to one place, volumes could help with that.</p>\n<p>They key here is this: bind mounts are file systems managed the host. They&#39;re just normal files in your host being mounted into a container. Volumes are different because they&#39;re a new file system that Docker manages that are mounted into your container. These Docker-managed file systems are not visible to the host system (they can be found but it&#39;s designed not to be.)</p>\n<p>Let&#39;s make a quick Node.js app that reads from a file that a number in it, prints it, writes it to a volume, and finishes. Create a new Node.js project.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">mkdir</span> docker-volume\n<span class=\"hljs-built_in\">cd</span> docker-volume\n<span class=\"hljs-built_in\">touch</span> index.js Dockerfile\n</code></pre><p>Inside that index.js file, put this:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;fs&quot;</span>).<span class=\"hljs-property\">promises</span>;\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>);\n\n<span class=\"hljs-keyword\">const</span> dataPath = path.<span class=\"hljs-title function_\">join</span>(process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">DATA_PATH</span> || <span class=\"hljs-string\">&quot;./data.txt&quot;</span>);\n\nfs.<span class=\"hljs-title function_\">readFile</span>(dataPath)\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">buffer</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> data = buffer.<span class=\"hljs-title function_\">toString</span>();\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data);\n    <span class=\"hljs-title function_\">writeTo</span>(+data + <span class=\"hljs-number\">1</span>);\n  })\n  .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;file not found, writing &#x27;0&#x27; to a new file&quot;</span>);\n    <span class=\"hljs-title function_\">writeTo</span>(<span class=\"hljs-number\">0</span>);\n  });\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">writeTo</span> = (<span class=\"hljs-params\">data</span>) =&gt; {\n  fs.<span class=\"hljs-title function_\">writeFile</span>(dataPath, data.<span class=\"hljs-title function_\">toString</span>()).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">error</span>);\n};\n</code></pre><p>Don&#39;t worry too much about the index.js. It looks for a file <code>$DATA_PATH</code> if it exists or <code>./data.txt</code> if it doesn&#39;t and if it exists, it reads it, logs it, and writes back to the data file after incrementing the number. If it just run it right now, it&#39;ll create a <code>data.txt</code> file with 0 in it. If you run it again, it&#39;ll have <code>1</code> in there and so on. So let&#39;s make this work with volumes.</p>\n<pre><code class=\"hljs language-dockerfile\"><span class=\"hljs-keyword\">FROM</span> node:<span class=\"hljs-number\">20</span>-alpine\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> --<span class=\"hljs-built_in\">chown</span>=node:node . /src</span>\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"language-bash\"> /src</span>\n<span class=\"hljs-keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"hljs-string\">&quot;node&quot;</span>, <span class=\"hljs-string\">&quot;index.js&quot;</span>]</span>\n</code></pre><p>Now run</p>\n<pre><code class=\"hljs language-bash\">docker build -t incrementor .\ndocker run --<span class=\"hljs-built_in\">rm</span> incrementor\n</code></pre><p>Every time you run this it&#39;ll be the same thing. This is nothing is persisted once the container finishes. We need something that can live between runs. We could use bind mounts and it would work but this data is only designed to be used and written to within Docker which makes volumes preferable and recommended by Docker. If you use volumes, Docker can handle back ups, clean ups, and more security for you. If you use bind mounts, you&#39;re on your own.</p>\n<p>So, without having to rebuild your container, try this</p>\n<pre><code class=\"hljs language-bash\">docker run --<span class=\"hljs-built_in\">rm</span> --<span class=\"hljs-built_in\">env</span> DATA_PATH=/data/num.txt --mount <span class=\"hljs-built_in\">type</span>=volume,src=incrementor-data,target=/data incrementor\n</code></pre><p>Now you should be to run it multiple times and everything should work! We use the <code>--env</code> flag to set the DATA_PATH to be where we want <code>index.js</code> to write the file and we use <code>--mount</code> to mount a named volume called <code>incrementor-data</code>. You can leave this out and it&#39;ll be an anonymous volume that will persist beyond the container but it won&#39;t automatically choose the right one on future runs. Awesome!</p>\n<h2>named pipes, tmpfs, and wrap up</h2>\n<p>Prefer to use volumes when you can, use bind mounts where it makes sense. If you&#39;re still unclear, the <a href=\"https://docs.docker.com/engine/storage/\">official Docker storage</a> docs are pretty good on the subject.</p>\n<p>There are two more that we didn&#39;t talk about, <code>tmpfs</code> and <code>npipe</code>. The former is Linux only and the latter is Windows only (we&#39;re not going over Windows containers at all in this workshop.) <code>tmpfs</code> imitates a file system but actually keeps everything in memory. This is useful for mounting in secrets like database keys or anything that wouldn&#39;t be persisted between container launches but you don&#39;t want to add to the Dockerfile. The latter is useful for mounting third party tools for Windows containers. If you need more info than that, refer to the docs. I&#39;ve never directly used either.</p>\n","markdown":"\nBind mounts are great for when you need to share data between your host and your container as we just learned. Volumes, on the other hand, are so that your containers can maintain state between runs. So if you have a container that runs and the next time it runs it needs the results from the previous time it ran, volumes are going to be helpful. Volumes can not only be shared by the same container-type between runs but also between different containers. Maybe if you have two containers and you want to log to consolidate your logs to one place, volumes could help with that.\n\nThey key here is this: bind mounts are file systems managed the host. They're just normal files in your host being mounted into a container. Volumes are different because they're a new file system that Docker manages that are mounted into your container. These Docker-managed file systems are not visible to the host system (they can be found but it's designed not to be.)\n\nLet's make a quick Node.js app that reads from a file that a number in it, prints it, writes it to a volume, and finishes. Create a new Node.js project.\n\n```bash\nmkdir docker-volume\ncd docker-volume\ntouch index.js Dockerfile\n```\n\nInside that index.js file, put this:\n\n```javascript\nconst fs = require(\"fs\").promises;\nconst path = require(\"path\");\n\nconst dataPath = path.join(process.env.DATA_PATH || \"./data.txt\");\n\nfs.readFile(dataPath)\n  .then((buffer) => {\n    const data = buffer.toString();\n    console.log(data);\n    writeTo(+data + 1);\n  })\n  .catch((e) => {\n    console.log(\"file not found, writing '0' to a new file\");\n    writeTo(0);\n  });\n\nconst writeTo = (data) => {\n  fs.writeFile(dataPath, data.toString()).catch(console.error);\n};\n```\n\nDon't worry too much about the index.js. It looks for a file `$DATA_PATH` if it exists or `./data.txt` if it doesn't and if it exists, it reads it, logs it, and writes back to the data file after incrementing the number. If it just run it right now, it'll create a `data.txt` file with 0 in it. If you run it again, it'll have `1` in there and so on. So let's make this work with volumes.\n\n```dockerfile\nFROM node:20-alpine\nCOPY --chown=node:node . /src\nWORKDIR /src\nCMD [\"node\", \"index.js\"]\n```\n\nNow run\n\n```bash\ndocker build -t incrementor .\ndocker run --rm incrementor\n```\n\nEvery time you run this it'll be the same thing. This is nothing is persisted once the container finishes. We need something that can live between runs. We could use bind mounts and it would work but this data is only designed to be used and written to within Docker which makes volumes preferable and recommended by Docker. If you use volumes, Docker can handle back ups, clean ups, and more security for you. If you use bind mounts, you're on your own.\n\nSo, without having to rebuild your container, try this\n\n```bash\ndocker run --rm --env DATA_PATH=/data/num.txt --mount type=volume,src=incrementor-data,target=/data incrementor\n```\n\nNow you should be to run it multiple times and everything should work! We use the `--env` flag to set the DATA_PATH to be where we want `index.js` to write the file and we use `--mount` to mount a named volume called `incrementor-data`. You can leave this out and it'll be an anonymous volume that will persist beyond the container but it won't automatically choose the right one on future runs. Awesome!\n\n## named pipes, tmpfs, and wrap up\n\nPrefer to use volumes when you can, use bind mounts where it makes sense. If you're still unclear, the [official Docker storage](https://docs.docker.com/engine/storage/) docs are pretty good on the subject.\n\nThere are two more that we didn't talk about, `tmpfs` and `npipe`. The former is Linux only and the latter is Windows only (we're not going over Windows containers at all in this workshop.) `tmpfs` imitates a file system but actually keeps everything in memory. This is useful for mounting in secrets like database keys or anything that wouldn't be persisted between container launches but you don't want to add to the Dockerfile. The latter is useful for mounting third party tools for Windows containers. If you need more info than that, refer to the docs. I've never directly used either.\n","slug":"volumes","title":"Volumes","section":"Docker Features","icon":"box","filePath":"/home/runner/work/complete-intro-to-containers-v2/complete-intro-to-containers-v2/lessons/06-docker-features/B-volumes.md","nextSlug":"/lessons/docker-features/dev-containers","prevSlug":"/lessons/docker-features/bind-mounts"}},"__N_SSG":true}